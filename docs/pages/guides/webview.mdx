---
title: WebViews in Expo
sidebar_title: WebViews
description: Learn about rendering DOM elements in Expo native apps.
---

import { Collapsible } from '~/ui/components/Collapsible';
import { Step } from '~/ui/components/Step';
import { Tab, Tabs } from '~/ui/components/Tabs';

Expo offers a novel approach to working with modern web code directly in a native app via the `"use webview"` directive. This enables incremental migration for an entire website to a universal app, simply moving on a per-component basis.

The Expo native runtime generally does not support using `<div>` or `<img>` tags, but you may find that you want to quickly drop in some web components. This is where webviews come in.

## Usage

To render a web component, simply add the `"use webview"` directive to the top of a file:

```js my-component.js (web)
'use webview';

export default function MyComponent() {
  return (
    <div>
      <h1>Hello, world!</h1>
    </div>
  );
}
```

```js App.js (native)
import MyComponent from './my-component.js';

export default function App() {
  return (
    // This component is a WebView from react-native-webview.
    <MyComponent style={{ backgroundColor: 'dodgerblue' }} />
  );
}
```

## Features

- Shared bundler config across web native and webviews.
- React, TypeScript, CSS, and all other Metro features are enabled in webview components.
- Logging in the terminal.
- Fast Refresh and HMR.
- Embedded exports for offline support.
- Assets are handled the same way as in the native app.
- WebView bundles can be introspected in Expo Atlas for debugging.
- Access to all web functionality without needing a native rebuild.

## Communication

You can send and receive serializable data between your native app and webviews using the `useBridge` API from `expo/webview`:

```js App.js (native)
import MyComponent from './my-component';
import { useBridge } from 'expo/webview';

export default function App() {
  const [emit, bridge] = useBridge(data => {
    console.log('Message from webview:', data);
  });
  return (
    <>
      <MyComponent {...bridge} />
      <Text onPress={() => emit({ type: 'hello', data: 'world' })}>Send message</Text>
    </>
  );
}
```

```js my-component.js (web)
'use webview';

import { useBridge } from 'expo/webview';

export default function MyComponent() {
  const [emit] = useBridge(data => {
    console.log('Message from native:', data);
  });
  return (
    <div>
      <h1>Hello, world!</h1>
      <button onClick={() => emit({ type: 'hello', data: 'world' })}>Send message to native</button>
    </div>
  );
}
```

Data cannot contain functions or circular references. On the web-side you can use the imperative APIs `emit` and `addEventListener` without having to go through React. The native side is more limited since it can host multiple webviews and therefore needs to attach different instances of the event emitters.

```js my-api.js (web)
import { emit, addEventListener } from 'expo/webview';

export function sendData() {
  emit({ type: 'hello', data: 'world' });
}

// Observe any data from the native side.
const remove = addEventListener('hello', data => {
  console.log('Message from native:', data);
});

// unsubscribe from events:
remove();
```

All communication is currently global and not scoped to a single webview. This could be changed in the future if needed.

## Feature detection

Because webview components are simply web components, you may find yourself needing extra qualifiers to better support libraries. You can detect if a component is running in a webview with the following:

```js
if (
  typeof window !== 'undefined' &&
  // Detect if the webview global is available.
  typeof window.ReactNativeWebView !== 'undefined'
) {
  // ...
}
```

## Debugging

By default, all `console.log` methods are extended in WebViews to forward logs to the terminal. This makes it fast and easy to see what's happening in your webview components.

Expo also enables WebView inspection and debugging when bundling in development mode. This means you can open Safari > Develop > Simulator > `@iframe` to see the webview's console and inspect elements.

## Manual WebViews

You can still create a manual webview using the `WebView` component from `react-native-webview`:

```js App.js (native)
import { WebView } from 'react-native-webview';

export default function App() {
  return <WebView source={{ html: '<h1>Hello, world!</h1>' }} />;
}
```

This can be useful for rendering websites from a remote server.

## Architecture

Built-in webview support only renders content as single-page applications (e.g. no SSR or SSG). This is because it's a bit simpler to work with and because you don't need browser indexing techniques in your embedded JS code.

When a module is marked with `"use webview"`, the module is replaced with a proxy reference which is imported at runtime. This feature is primarily just a number of bundler and CLI magic tricks. You can always use a webview with the stnadard approach by passing raw HTML to a webview component if you'd like.

If you import a webview component from another webview, the component will just be one large webview. This is because web content is passed directly through and not wrapped in an iframe.

Overall, this system shares a lot of similarities with Expo's React Server Components implementation.

## Considerations

We recommend always building truly native apps using universal primitives such as `View`, `Image`, and `Text`. WebViews only support standard JavaScript which is slower to parse and startup than Hermes bytecode.

Data can only be sent between webviews and your native app via an async JSON transport system. Avoid depending on data across JS engines. Also avoid deep linking to nested URLs in webviews.

If you have a global state for sharing data this won't be available across JS engines.

While native modules in the Expo SDK can be optimized to support webviews, we haven't done this yet.

While you should avoid using WebViews for your main app, there are some reasonable uses for them. For example, WebViews are conceptually the best way to render rich text and markdown. WebViews also have very good WebGL support.

Many large apps also use WebViews for auxiliary routes such as settings pages, help pages, and other less frequently visited parts of the app.

## Embedding vs Hosting

Webviews support both fetching from a server and reading from disk. By default, Expo's webview support embeds the web content and assets on disk to reduce version conflicts and improve performance. This can be extended in the future to support conditionally hosting components as part of our larger universal React Server Components work.

## Direction

Ultimately, universal architecture is the most exciting direction. Our extensive universal tooling is the only reason we can even offer a feature as intricate and valuable as this one.

While webview components help with migration and moving quickly, we recommend using universal views whenever possible.
