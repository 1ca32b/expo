{"version":3,"file":"loadStaticParamsAsync.js","names":["loadStaticParamsAsync","route","expandedChildren","Promise","all","children","map","loadStaticParamsRecursive","parentParams","flat","props","dynamic","length","loaded","loadRoute","staticParams","generateStaticParams","params","assertStaticParamsType","forEach","assertStaticParams","traverseForNode","nextParams","nextChildren","child","push","uniqBy","i","createParsedRouteName","input","parsedRouteName","query","param","name","formattedParameter","Array","isArray","join","deep","replace","generatedRoutes","dynamicChildren","parsedRoute","generatedContextKey","contextKey","array","key","seen","filter","item","k","Error","formatExpected","expected","received","total","String","Object","entries","value","matches","every","undefined","plural","v","validateSingleParam","allowMultipleSegments","parts","split","Boolean","parameter"],"sources":["../../src/loadStaticParamsAsync.ts"],"sourcesContent":["import type { DynamicConvention, RouteNode } from './Route';\n\nexport async function loadStaticParamsAsync(route: RouteNode): Promise<RouteNode> {\n  const expandedChildren = await Promise.all(\n    route.children.map((route) => loadStaticParamsRecursive(route, { parentParams: {} }))\n  );\n  route.children = expandedChildren.flat();\n  return route;\n}\n\nasync function loadStaticParamsRecursive(\n  route: RouteNode,\n  props: { parentParams: any }\n): Promise<RouteNode[]> {\n  if (!route?.dynamic && !route?.children?.length) {\n    return [route];\n  }\n\n  const loaded = await route.loadRoute();\n\n  let staticParams: Record<string, string | string[]>[] = [];\n\n  if (loaded.generateStaticParams) {\n    staticParams = await loaded.generateStaticParams({\n      params: props.parentParams || {},\n    });\n\n    assertStaticParamsType(staticParams);\n    // Assert that at least one param from each matches the dynamic route.\n    staticParams.forEach((params) => assertStaticParams(route, params));\n  }\n\n  const traverseForNode = async (nextParams: Record<string, string | string[]>) => {\n    const nextChildren: RouteNode[] = [];\n    for (const child of route.children) {\n      const children = await loadStaticParamsRecursive(child, {\n        ...props,\n        parentParams: nextParams,\n      });\n      nextChildren.push(...children);\n    }\n\n    return uniqBy(nextChildren, (i) => i.route);\n  };\n\n  if (!staticParams.length) {\n    const nextParams = {\n      ...props.parentParams,\n    };\n\n    route.children = await traverseForNode(nextParams);\n\n    return [route];\n  }\n\n  const createParsedRouteName = (input: string, params: any) => {\n    let parsedRouteName = input;\n    route.dynamic?.map((query) => {\n      const param = params[query.name];\n      const formattedParameter = Array.isArray(param) ? param.join('/') : param;\n      if (query.deep) {\n        parsedRouteName = parsedRouteName.replace(`[...${query.name}]`, formattedParameter);\n      } else {\n        parsedRouteName = parsedRouteName.replace(`[${query.name}]`, param);\n      }\n    });\n\n    return parsedRouteName;\n  };\n\n  const generatedRoutes = await Promise.all(\n    staticParams.map(async (params) => {\n      const nextParams = {\n        ...props.parentParams,\n        ...params,\n      };\n\n      const dynamicChildren = await traverseForNode(nextParams);\n      const parsedRoute = createParsedRouteName(route.route, params);\n      const generatedContextKey = createParsedRouteName(route.contextKey, params);\n\n      return {\n        ...route,\n        // TODO: Add a new field for this\n        contextKey: generatedContextKey,\n        // Convert the dynamic route to a static route.\n        dynamic: null,\n        route: parsedRoute,\n        children: dynamicChildren,\n      };\n    })\n  );\n\n  return [route, ...generatedRoutes];\n}\n\n/** lodash.uniqBy */\nfunction uniqBy<T>(array: T[], key: (item: T) => string): T[] {\n  const seen: Record<string, boolean> = {};\n  return array.filter((item) => {\n    const k = key(item);\n    if (seen[k]) {\n      return false;\n    }\n    seen[k] = true;\n    return true;\n  });\n}\n\nfunction assertStaticParamsType(params: any): asserts params is Record<string, string | string[]> {\n  if (!Array.isArray(params)) {\n    throw new Error(`generateStaticParams() must return an array of params, received ${params}`);\n  }\n}\n\nfunction formatExpected(expected: string[], received: Record<string, any>): string {\n  const total = {\n    ...received,\n  };\n  for (const item of expected) {\n    if (total[item] == null) {\n      total[item] = String(total[item]);\n    } else {\n      total[item] = `\"${total[item]}\"`;\n    }\n  }\n\n  return [\n    '{',\n    Object.entries(total)\n      .map(([key, value]) => `  \"${key}\": ${value}`)\n      .join(',\\n'),\n    '}',\n  ].join('\\n');\n}\n\nexport function assertStaticParams(\n  route: Pick<RouteNode, 'contextKey' | 'dynamic'>,\n  params: Record<string, string | string[]>\n) {\n  // Type checking\n  if (!route.dynamic) {\n    throw new Error('assertStaticParams() must be called on a dynamic route.');\n  }\n  const matches = route.dynamic.every((dynamic) => {\n    const value = params[dynamic.name];\n    return value !== undefined && value !== null;\n  });\n  if (!matches) {\n    const plural = route.dynamic.length > 1 ? 's' : '';\n    const expected = route.dynamic.map((dynamic) => dynamic.name);\n    throw new Error(\n      `[${\n        route.contextKey\n      }]: generateStaticParams() must return an array of params that match the dynamic route${plural}. Expected non-nullish values for key${plural}: ${expected\n        .map((v) => `\"${v}\"`)\n        .join(', ')}.\\nReceived:\\n${formatExpected(expected, params)}`\n    );\n  }\n\n  const validateSingleParam = (\n    dynamic: DynamicConvention,\n    value: any,\n    allowMultipleSegments?: boolean\n  ) => {\n    if (typeof value !== 'string') {\n      throw new Error(\n        `generateStaticParams() for route \"${route.contextKey}\" expected param \"${\n          dynamic.name\n        }\" to be of type string, instead found \"${typeof value}\" while parsing \"${value}\".`\n      );\n    }\n    const parts = value.split('/').filter(Boolean);\n    if (parts.length > 1 && !allowMultipleSegments) {\n      throw new Error(\n        `generateStaticParams() for route \"${route.contextKey}\" expected param \"${dynamic.name}\" to not contain \"/\" (multiple segments) while parsing \"${value}\".`\n      );\n    }\n    if (parts.length === 0) {\n      throw new Error(\n        `generateStaticParams() for route \"${route.contextKey}\" expected param \"${dynamic.name}\" not to be empty while parsing \"${value}\".`\n      );\n    }\n  };\n\n  // `[shape]/bar/[...colors]` -> `[shape]`, `[...colors]`\n  for (const dynamic of route.dynamic) {\n    let parameter = params[dynamic.name];\n    if (dynamic.deep) {\n      if (Array.isArray(parameter)) {\n        parameter = parameter.filter(Boolean).join('/');\n      }\n      validateSingleParam(dynamic, parameter, true);\n    } else {\n      validateSingleParam(dynamic, parameter);\n    }\n  }\n}\n"],"mappings":"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"}