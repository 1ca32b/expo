{"version":3,"file":"getPathFromState.js","names":["_core","data","require","_matchers","DEFAULT_SCREENS","getActiveRoute","state","route","index","routes","length","isInvalidParams","params","createFakeState","stale","type","key","routeNames","name","screen","path","segmentMatchesConvention","segment","matchDynamicName","matchGroupName","matchDeepDynamicRouteName","encodeURIComponentPreservingBrackets","str","encodeURIComponent","replace","getPathFromState","_options","getPathDataFromState","screens","Error","preserveGroups","preserveDynamicRoutes","options","validatePathConfig","Object","is","getPathFromResolvedState","JSON","parse","stringify","createNormalizedConfigs","processParamsWithUserSettings","configItem","fromEntries","entries","map","value","Array","isArray","String","deepEqual","a","b","i","keysA","keys","keysB","walkConfigItems","focusedRoute","configs","pattern","focusedParams","hash","collectedParams","inputPattern","undefined","assign","getParamsWithConventionsCollapsed","routeName","initialRouteName","initialRouteConfig","nextRoute","nestedScreens","join","current","allParams","$hash","getPathWithConventionsCollapsed","routePath","param","query","URLSearchParams","toString","decodeParams","appendBaseUrl","basicSanitizePath","parsed","v","decodeURIComponent","segments","split","p","getParamName","startsWith","slice","processedParams","filter","forEach","some","testNotFound","simplifiedPath","initial","joinPaths","paths","concat","Boolean","createConfigItem","config","parentPattern","exact","c","baseUrl","process","env","EXPO_BASE_URL","NODE_ENV"],"sources":["../../../src/fork/getPathFromState.ts"],"sourcesContent":["import { PathConfig, PathConfigMap, validatePathConfig } from '@react-navigation/core';\nimport type { NavigationState, PartialState, Route } from '@react-navigation/routers';\n\nimport {\n  matchDeepDynamicRouteName,\n  matchDynamicName,\n  matchGroupName,\n  testNotFound,\n} from '../matchers';\n\ntype Options<ParamList extends object> = {\n  initialRouteName?: string;\n  screens: PathConfigMap<ParamList>;\n};\n\nexport type State = NavigationState | Omit<PartialState<NavigationState>, 'stale'>;\n\ntype StringifyConfig = Record<string, (value: any) => string>;\n\ntype ConfigItem = {\n  pattern?: string;\n  stringify?: StringifyConfig;\n  screens?: Record<string, ConfigItem>;\n  // Used as fallback for groups\n  initialRouteName?: string;\n};\n\ntype CustomRoute = Route<string> & {\n  state?: State;\n};\n\nconst DEFAULT_SCREENS: PathConfigMap<object> = {};\n\nconst getActiveRoute = (state: State): { name: string; params?: object } => {\n  const route =\n    typeof state.index === 'number'\n      ? state.routes[state.index]\n      : state.routes[state.routes.length - 1];\n\n  if (route.state) {\n    return getActiveRoute(route.state);\n  }\n\n  if (route && isInvalidParams(route.params)) {\n    return getActiveRoute(createFakeState(route.params));\n  }\n\n  return route;\n};\n\nfunction createFakeState(params: StateAsParams) {\n  return {\n    stale: false,\n    type: 'UNKNOWN',\n    key: 'UNKNOWN',\n    index: 0,\n    routeNames: [],\n    routes: [\n      {\n        key: 'UNKNOWN',\n        name: params.screen,\n        params: params.params,\n        path: params.path,\n      },\n    ],\n  };\n}\n\nfunction segmentMatchesConvention(segment: string): boolean {\n  return (\n    segment === 'index' ||\n    matchDynamicName(segment) != null ||\n    matchGroupName(segment) != null ||\n    matchDeepDynamicRouteName(segment) != null\n  );\n}\n\nfunction encodeURIComponentPreservingBrackets(str: string) {\n  return encodeURIComponent(str).replace(/%5B/g, '[').replace(/%5D/g, ']');\n}\n\n/**\n * Utility to serialize a navigation state object to a path string.\n *\n * @example\n * ```js\n * getPathFromState(\n *   {\n *     routes: [\n *       {\n *         name: 'Chat',\n *         params: { author: 'Jane', id: 42 },\n *       },\n *     ],\n *   },\n *   {\n *     screens: {\n *       Chat: {\n *         path: 'chat/:author/:id',\n *         stringify: { author: author => author.toLowerCase() }\n *       }\n *     }\n *   }\n * )\n * ```\n *\n * @param state Navigation state to serialize.\n * @param options Extra options to fine-tune how to serialize the path.\n * @returns Path representing the state, e.g. /foo/bar?count=42.\n */\nexport default function getPathFromState<ParamList extends object>(\n  state: State,\n  _options?: Options<ParamList> & {\n    preserveGroups?: boolean;\n    preserveDynamicRoutes?: boolean;\n  }\n): string {\n  return getPathDataFromState(state, _options).path;\n}\n\nexport function getPathDataFromState<ParamList extends object>(\n  state: State,\n  _options: Options<ParamList> & {\n    preserveGroups?: boolean;\n    preserveDynamicRoutes?: boolean;\n  } = { screens: DEFAULT_SCREENS }\n) {\n  if (state == null) {\n    throw Error(\"Got 'undefined' for the navigation state. You must pass a valid state object.\");\n  }\n\n  const { preserveGroups, preserveDynamicRoutes, ...options } = _options;\n\n  validatePathConfig(options);\n\n  // Expo Router disallows usage without a linking config.\n  if (Object.is(options.screens, DEFAULT_SCREENS)) {\n    throw Error(\"You must pass a 'screens' object to 'getPathFromState' to generate a path.\");\n  }\n\n  return getPathFromResolvedState(\n    JSON.parse(JSON.stringify(state)),\n    // Create a normalized configs object which will be easier to use\n    createNormalizedConfigs(options.screens),\n    { preserveGroups, preserveDynamicRoutes }\n  );\n}\n\nfunction processParamsWithUserSettings(configItem: ConfigItem, params: Record<string, any>) {\n  const stringify = configItem?.stringify;\n\n  return Object.fromEntries(\n    Object.entries(params).map(([key, value]) => [\n      key,\n      // TODO: Strip nullish values here.\n      stringify?.[key]\n        ? stringify[key](value)\n        : // Preserve rest params\n          Array.isArray(value)\n          ? value\n          : String(value),\n    ])\n  );\n}\n\nexport function deepEqual(a: any, b: any) {\n  if (a === b) {\n    return true;\n  }\n\n  if (Array.isArray(a) && Array.isArray(b)) {\n    if (a.length !== b.length) {\n      return false;\n    }\n\n    for (let i = 0; i < a.length; i++) {\n      if (!deepEqual(a[i], b[i])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  if (typeof a === 'object' && typeof b === 'object') {\n    const keysA = Object.keys(a);\n    const keysB = Object.keys(b);\n\n    if (keysA.length !== keysB.length) {\n      return false;\n    }\n\n    for (const key of keysA) {\n      if (!deepEqual(a[key], b[key])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  return false;\n}\n\nfunction walkConfigItems(\n  route: CustomRoute,\n  focusedRoute: {\n    name: string;\n    params?: object;\n  },\n  configs: Record<string, ConfigItem>,\n  {\n    preserveDynamicRoutes,\n  }: {\n    preserveDynamicRoutes?: boolean;\n  }\n) {\n  // NOTE(EvanBacon): Fill in current route using state that was passed as params.\n  if (!route.state && isInvalidParams(route.params)) {\n    route.state = createFakeState(route.params);\n  }\n\n  let pattern: string | null = null;\n  let focusedParams: Record<string, any> | undefined;\n  let hash: string | undefined;\n\n  const collectedParams: Record<string, any> = {};\n\n  while (route.name in configs) {\n    const configItem = configs[route.name];\n    const inputPattern = configItem.pattern;\n\n    if (inputPattern == null) {\n      // This should never happen in Expo Router.\n      throw new Error('Unexpected: No pattern found for route ' + route.name);\n    }\n    pattern = inputPattern;\n\n    if (route.params) {\n      if (route.params['#']) {\n        hash = route.params['#'];\n        delete route.params['#'];\n      }\n\n      const params = processParamsWithUserSettings(configItem, route.params);\n      if (pattern !== undefined && pattern !== null) {\n        Object.assign(collectedParams, params);\n      }\n      if (deepEqual(focusedRoute, route)) {\n        if (preserveDynamicRoutes) {\n          focusedParams = params;\n        } else {\n          // If this is the focused route, keep the params for later use\n          // We save it here since it's been stringified already\n          focusedParams = getParamsWithConventionsCollapsed({\n            params,\n            pattern,\n            routeName: route.name,\n          });\n        }\n      }\n    }\n\n    if (!route.state && isInvalidParams(route.params)) {\n      route.state = createFakeState(route.params);\n    }\n\n    // If there is no `screens` property or no nested state, we return pattern\n    if (!configItem.screens || route.state === undefined) {\n      if (\n        configItem.initialRouteName &&\n        configItem.screens &&\n        configItem.initialRouteName in configItem.screens &&\n        configItem.screens[configItem.initialRouteName]?.pattern\n      ) {\n        const initialRouteConfig = configItem.screens[configItem.initialRouteName];\n\n        // NOTE(EvanBacon): Big hack to support initial route changes in tab bars.\n        pattern = initialRouteConfig.pattern!;\n        if (focusedParams) {\n          if (!preserveDynamicRoutes) {\n            // If this is the focused route, keep the params for later use\n            // We save it here since it's been stringified already\n            focusedParams = getParamsWithConventionsCollapsed({\n              params: focusedParams,\n              pattern,\n              routeName: route.name,\n            });\n          }\n        }\n      }\n      break;\n    }\n\n    const index = route.state.index ?? route.state.routes.length - 1;\n\n    const nextRoute = route.state.routes[index];\n    const nestedScreens = configItem.screens;\n\n    // if there is config for next route name, we go deeper\n    if (nestedScreens && nextRoute.name in nestedScreens) {\n      route = nextRoute as CustomRoute;\n      configs = nestedScreens;\n    } else {\n      // If not, there is no sense in going deeper in config\n      break;\n    }\n  }\n\n  if (pattern == null) {\n    throw new Error(\n      `No pattern found for route \"${route.name}\". Options are: ${Object.keys(configs).join(', ')}.`\n    );\n  }\n\n  if (pattern && !focusedParams && focusedRoute.params) {\n    if (preserveDynamicRoutes) {\n      focusedParams = focusedRoute.params;\n    } else {\n      // If this is the focused route, keep the params for later use\n      // We save it here since it's been stringified already\n      focusedParams = getParamsWithConventionsCollapsed({\n        params: focusedRoute.params,\n        pattern,\n        routeName: route.name,\n      });\n    }\n    Object.assign(focusedParams, collectedParams);\n  }\n\n  return {\n    pattern,\n    nextRoute: route,\n    focusedParams,\n    hash,\n    params: collectedParams,\n  };\n}\n\nfunction getPathFromResolvedState(\n  state: State,\n  configs: Record<string, ConfigItem>,\n  {\n    preserveGroups,\n    preserveDynamicRoutes,\n  }: { preserveGroups?: boolean; preserveDynamicRoutes?: boolean }\n) {\n  let path = '';\n  let current: State = state;\n  let hash: string | undefined;\n\n  const allParams: Record<string, any> = {};\n\n  while (current) {\n    path += '/';\n\n    // Make mutable copies to ensure we don't leak state outside of the function.\n    const route = current.routes[current.index ?? 0] as CustomRoute;\n\n    // NOTE(EvanBacon): Fill in current route using state that was passed as params.\n    // if (isInvalidParams(route.params)) {\n    if (!route.state && isInvalidParams(route.params)) {\n      route.state = createFakeState(route.params);\n    }\n\n    const {\n      pattern,\n      params,\n      nextRoute,\n      focusedParams,\n      hash: $hash,\n    } = walkConfigItems(route, getActiveRoute(current), { ...configs }, { preserveDynamicRoutes });\n\n    if ($hash) {\n      hash = $hash;\n    }\n\n    Object.assign(allParams, params);\n\n    path += getPathWithConventionsCollapsed({\n      pattern,\n      routePath: nextRoute.path,\n      params: allParams,\n      initialRouteName: configs[nextRoute.name]?.initialRouteName,\n      preserveGroups,\n      preserveDynamicRoutes,\n    });\n\n    if (\n      nextRoute.state &&\n      // NOTE(EvanBacon): The upstream implementation allows for sending in synthetic states (states that weren't generated by `getStateFromPath`)\n      // and any invalid routes will simply be ignored.\n      // Because of this, we need to check if the next route is valid before continuing, otherwise our more strict\n      // implementation will throw an error.\n      configs[nextRoute.state.routes?.[nextRoute.state?.index ?? 0]?.name]\n    ) {\n      // Continue looping with the next state if available.\n      current = nextRoute.state;\n    } else {\n      // Finished crawling state.\n\n      // Check for query params before exiting.\n      if (focusedParams) {\n        for (const param in focusedParams) {\n          // TODO: This is not good. We shouldn't squat strings named \"undefined\".\n          if (focusedParams[param] === 'undefined') {\n            // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n            delete focusedParams[param];\n          }\n        }\n\n        const query = new URLSearchParams(focusedParams).toString();\n        if (query) {\n          path += `?${query}`;\n        }\n      }\n      break;\n    }\n  }\n\n  if (hash) {\n    allParams['#'] = hash;\n    path += `#${hash}`;\n  }\n\n  const params = decodeParams(allParams);\n\n  return { path: appendBaseUrl(basicSanitizePath(path)), params };\n}\n\nfunction decodeParams(params: Record<string, string>) {\n  const parsed: Record<string, any> = {};\n\n  for (const [key, value] of Object.entries(params)) {\n    try {\n      if (Array.isArray(value)) {\n        parsed[key] = value.map((v) => decodeURIComponent(v));\n      } else {\n        parsed[key] = decodeURIComponent(value);\n      }\n    } catch {\n      parsed[key] = value;\n    }\n  }\n\n  return parsed;\n}\n\nfunction getPathWithConventionsCollapsed({\n  pattern,\n  routePath,\n  params,\n  preserveGroups,\n  preserveDynamicRoutes,\n  initialRouteName,\n}: {\n  pattern: string;\n  routePath?: string;\n  params: Record<string, any>;\n  preserveGroups?: boolean;\n  preserveDynamicRoutes?: boolean;\n  initialRouteName?: string;\n}) {\n  const segments = pattern.split('/');\n  return segments\n    .map((p, i) => {\n      const name = getParamName(p);\n\n      // We don't know what to show for wildcard patterns\n      // Showing the route name seems ok, though whatever we show here will be incorrect\n      // Since the page doesn't actually exist\n      if (p.startsWith('*')) {\n        if (preserveDynamicRoutes) {\n          if (name === 'not-found') {\n            return '+not-found';\n          }\n          return `[...${name}]`;\n        }\n        if (params[name]) {\n          if (Array.isArray(params[name])) {\n            return params[name].join('/');\n          }\n          return params[name];\n        }\n        if (i === 0) {\n          // This can occur when a wildcard matches all routes and the given path was `/`.\n          return routePath;\n        }\n        // remove existing segments from route.path and return it\n        // this is used for nested wildcard routes. Without this, the path would add\n        // all nested segments to the beginning of the wildcard route.\n        return routePath\n          ?.split('/')\n          .slice(i + 1)\n          .join('/');\n      }\n\n      // If the path has a pattern for a param, put the param in the path\n      if (p.startsWith(':')) {\n        if (preserveDynamicRoutes) {\n          return `[${name}]`;\n        }\n        // Optional params without value assigned in route.params should be ignored\n        return params[name];\n      }\n\n      if (!preserveGroups && matchGroupName(p) != null) {\n        // When the last part is a group it could be a shared URL\n        // if the route has an initialRouteName defined, then we should\n        // use that as the component path as we can assume it will be shown.\n        if (segments.length - 1 === i) {\n          if (initialRouteName) {\n            // Return an empty string if the init route is ambiguous.\n            if (segmentMatchesConvention(initialRouteName)) {\n              return '';\n            }\n            return encodeURIComponentPreservingBrackets(initialRouteName);\n          }\n        }\n        return '';\n      }\n      // Preserve dynamic syntax for rehydration\n      return encodeURIComponentPreservingBrackets(p);\n    })\n    .map((v) => v ?? '')\n    .join('/');\n}\n\n/** Given a set of query params and a pattern with possible conventions, collapse the conventions and return the remaining params. */\nfunction getParamsWithConventionsCollapsed({\n  pattern,\n  routeName,\n  params,\n}: {\n  pattern: string;\n  /** Route name is required for matching the wildcard route. This is specific to Expo Router. */\n  routeName: string;\n  params: object;\n}): Record<string, string> {\n  const processedParams: Record<string, string> = { ...params };\n\n  // Remove the params present in the pattern since we'll only use the rest for query string\n\n  const segments = pattern.split('/');\n\n  // Dynamic Routes\n  segments\n    .filter((segment) => segment.startsWith(':'))\n    .forEach((segment) => {\n      const name = getParamName(segment);\n      delete processedParams[name];\n    });\n\n  // Deep Dynamic Routes\n  if (segments.some((segment) => segment.startsWith('*'))) {\n    // NOTE(EvanBacon): Drop the param name matching the wildcard route name -- this is specific to Expo Router.\n    const name = testNotFound(routeName)\n      ? 'not-found'\n      : matchDeepDynamicRouteName(routeName) ?? routeName;\n    delete processedParams[name];\n  }\n\n  return processedParams;\n}\n\n// Remove multiple as well as trailing slashes\nfunction basicSanitizePath(path: string) {\n  // Remove duplicate slashes like `foo//bar` -> `foo/bar`\n  const simplifiedPath = path.replace(/\\/+/g, '/');\n  if (simplifiedPath.length <= 1) {\n    return simplifiedPath;\n  }\n  // Remove trailing slash like `foo/bar/` -> `foo/bar`\n  return simplifiedPath.replace(/\\/$/, '');\n}\n\ntype StateAsParams = {\n  initial: boolean;\n  path?: string;\n  screen: string;\n  params: Record<string, any>;\n};\n\n// TODO: Make StackRouter not do this...\n// Detect if the params came from StackRouter using `params` to pass around internal state.\nfunction isInvalidParams(params?: Record<string, any>): params is StateAsParams {\n  if (!params) {\n    return false;\n  }\n\n  if ('params' in params && typeof params.params === 'object' && !!params.params) {\n    return true;\n  }\n\n  return (\n    'initial' in params &&\n    typeof params.initial === 'boolean' &&\n    // \"path\" in params &&\n    'screen' in params\n  );\n}\n\nconst getParamName = (pattern: string) => pattern.replace(/^[:*]/, '').replace(/\\?$/, '');\n\nconst joinPaths = (...paths: string[]): string =>\n  ([] as string[])\n    .concat(...paths.map((p) => p.split('/')))\n    .filter(Boolean)\n    .join('/');\n\nconst createConfigItem = (\n  config: PathConfig<object> | string,\n  parentPattern?: string\n): ConfigItem => {\n  if (typeof config === 'string') {\n    // If a string is specified as the value of the key(e.g. Foo: '/path'), use it as the pattern\n    const pattern = parentPattern ? joinPaths(parentPattern, config) : config;\n\n    return { pattern };\n  }\n\n  if (config.exact && config.path === undefined) {\n    throw new Error(\n      \"A 'path' needs to be specified when specifying 'exact: true'. If you don't want this screen in the URL, specify it as empty string, e.g. `path: ''`.\"\n    );\n  }\n\n  // If an object is specified as the value (e.g. Foo: { ... }),\n  // It can have `path` property and `screens` prop which has nested configs\n  const pattern =\n    config.exact !== true ? joinPaths(parentPattern || '', config.path || '') : config.path || '';\n\n  const screens = config.screens ? createNormalizedConfigs(config.screens, pattern) : undefined;\n\n  return {\n    // Normalize pattern to remove any leading, trailing slashes, duplicate slashes etc.\n    pattern: pattern?.split('/').filter(Boolean).join('/'),\n    stringify: config.stringify,\n    screens,\n    initialRouteName: config.initialRouteName,\n  };\n};\n\nconst createNormalizedConfigs = (\n  options: PathConfigMap<object>,\n  pattern?: string\n): Record<string, ConfigItem> =>\n  Object.fromEntries(\n    Object.entries(options).map(([name, c]) => [name, createConfigItem(c, pattern)])\n  );\n\nexport function appendBaseUrl(\n  path: string,\n  baseUrl: string | undefined = process.env.EXPO_BASE_URL\n) {\n  if (process.env.NODE_ENV !== 'development') {\n    if (baseUrl) {\n      return `/${baseUrl.replace(/^\\/+/, '').replace(/\\/$/, '')}${path}`;\n    }\n  }\n  return path;\n}\n"],"mappings":"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"}