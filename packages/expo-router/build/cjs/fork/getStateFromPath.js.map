{"version":3,"file":"getStateFromPath.js","names":["_escapeStringRegexp","data","_interopRequireDefault","require","_findFocusedRoute","_validatePathConfig","_matchers","obj","__esModule","default","getUrlWithReactNavigationConcessions","path","baseUrl","process","env","EXPO_BASE_URL","parsed","URL","nonstandardPathname","inputPathnameWithoutHash","url","pathname","stripBaseUrl","replace","getStateFromPath","options","initialRoutes","configs","getMatchableRouteConfigs","getStateFromPathWithConfigs","validatePathConfig","screens","Error","initialRouteName","push","parentScreens","converted","Object","keys","map","key","createNormalizedConfigs","flat","resolvedInitialPatterns","route","joinPaths","convertedWithInitial","config","isInitial","includes","routeNames","join","sort","sortConfigs","assertConfigDuplicates","reduce","acc","indexedKey","regex","toString","pattern","alpha","hasChildren","a","b","intersects","length","every","it","i","last","split","pop","match","routeType","startsWith","userReadableName","assign","localeCompare","screen","aParts","filter","part","matchGroupName","bParts","Math","max","aWildCard","bWildCard","aNotFound","bNotFound","aSlug","bSlug","getStateFromEmptyPathWithConfigs","leafNodes","value","stripGroupSegmentsFromPath","find","test","undefined","routes","name","_route","createNestedStateObject","formattedPaths","cleanPath","search","slice","matchAgainstConfigs","paths","concat","p","Boolean","remaining","remainingPath","matchedParams","routeFromName","c","segments","params","forEach","parse","combinedParams","r","hasCombinedParams","equalHeritage","routeConfig","initials","parentPattern","createConfigItem","exact","nestedConfig","result","formatRegexPattern","endsWith","escape","RegExp","findParseConfigForRoute","routeName","routeConfigs","findInitialRoute","createStateObject","isEmpty","initialRoute","index","state","shift","nestedState","nestedStateIndex","findFocusedRoute","parseQueryParams","create","entries","NODE_ENV","console","warn","parseConfig","query","searchParams","URLSearchParams","fromEntries","hasOwnProperty","call","baseUrlCache","Map","getBaseUrlRegex","has","get","set","reg"],"sources":["../../../src/fork/getStateFromPath.ts"],"sourcesContent":["import { PathConfigMap } from '@react-navigation/core';\nimport type { InitialState, NavigationState, PartialState } from '@react-navigation/routers';\nimport escape from 'escape-string-regexp';\n\nimport { findFocusedRoute } from './findFocusedRoute';\nimport validatePathConfig from './validatePathConfig';\nimport { RouteNode } from '../Route';\nimport { matchGroupName, stripGroupSegmentsFromPath } from '../matchers';\n\ntype Options<ParamList extends object> = {\n  initialRouteName?: string;\n  screens: PathConfigMap<ParamList>;\n};\n\ntype ParseConfig = Record<string, (value: string) => any>;\n\ntype RouteConfig = {\n  isInitial?: boolean;\n  screen: string;\n  regex?: RegExp;\n  path: string;\n  pattern: string;\n  routeNames: string[];\n  parse?: ParseConfig;\n  hasChildren: boolean;\n  userReadableName: string;\n  _route?: RouteNode;\n};\n\ntype InitialRouteConfig = {\n  initialRouteName: string;\n  parentScreens: string[];\n};\n\nexport type ResultState = PartialState<NavigationState> & {\n  state?: ResultState;\n};\n\ntype ParsedRoute = {\n  name: string;\n  path?: string;\n  params?: Record<string, any>;\n};\n\nexport function getUrlWithReactNavigationConcessions(\n  path: string,\n  baseUrl: string | undefined = process.env.EXPO_BASE_URL\n) {\n  let parsed: URL;\n  try {\n    parsed = new URL(path, 'https://phony.example');\n  } catch {\n    // Do nothing with invalid URLs.\n    return {\n      nonstandardPathname: '',\n      inputPathnameWithoutHash: '',\n      url: null,\n    };\n  }\n\n  const pathname = parsed.pathname;\n\n  // Make sure there is a trailing slash\n  return {\n    // The slashes are at the end, not the beginning\n    nonstandardPathname:\n      stripBaseUrl(pathname, baseUrl).replace(/^\\/+/g, '').replace(/\\/+$/g, '') + '/',\n\n    // React Navigation doesn't support hashes, so here\n    inputPathnameWithoutHash: stripBaseUrl(path, baseUrl).replace(/#.*$/, ''),\n    url: parsed,\n  };\n}\n\n/**\n * Utility to parse a path string to initial state object accepted by the container.\n * This is useful for deep linking when we need to handle the incoming URL.\n *\n * @example\n * ```js\n * getStateFromPath(\n *   '/chat/jane/42',\n *   {\n *     screens: {\n *       Chat: {\n *         path: 'chat/:author/:id',\n *         parse: { id: Number }\n *       }\n *     }\n *   }\n * )\n * ```\n * @param path Path string to parse and convert, e.g. /foo/bar?count=42.\n * @param options Extra options to fine-tune how to parse the path.\n */\nexport default function getStateFromPath<ParamList extends object>(\n  path: string,\n  options?: Options<ParamList>\n): ResultState | undefined {\n  const { initialRoutes, configs } = getMatchableRouteConfigs(options);\n\n  return getStateFromPathWithConfigs(path, configs, initialRoutes);\n}\n\nexport function getMatchableRouteConfigs<ParamList extends object>(options?: Options<ParamList>) {\n  if (options) {\n    validatePathConfig(options);\n  }\n\n  const screens = options?.screens;\n  // Expo Router disallows usage without a linking config.\n  if (!screens) {\n    throw Error(\"You must pass a 'screens' object to 'getStateFromPath' to generate a path.\");\n  }\n\n  // This will be mutated...\n  const initialRoutes: InitialRouteConfig[] = [];\n\n  if (options?.initialRouteName) {\n    initialRoutes.push({\n      initialRouteName: options.initialRouteName,\n      parentScreens: [],\n    });\n  }\n\n  // Create a normalized configs array which will be easier to use.\n  const converted = Object.keys(screens)\n    .map((key) => createNormalizedConfigs(key, screens, [], initialRoutes))\n    .flat();\n\n  const resolvedInitialPatterns = initialRoutes.map((route) =>\n    joinPaths(...route.parentScreens, route.initialRouteName)\n  );\n\n  const convertedWithInitial = converted.map((config) => ({\n    ...config,\n    // TODO(EvanBacon): Probably a safer way to do this\n    // Mark initial routes to give them potential priority over other routes that match.\n    isInitial: resolvedInitialPatterns.includes(config.routeNames.join('/')),\n  }));\n\n  // Sort in order of resolution. This is extremely important for the algorithm to work.\n  const configs = convertedWithInitial.sort(sortConfigs);\n\n  // Assert any duplicates before we start parsing.\n  assertConfigDuplicates(configs);\n\n  return { configs, initialRoutes };\n}\n\nfunction assertConfigDuplicates(configs: RouteConfig[]) {\n  // Check for duplicate patterns in the config\n  configs.reduce<Record<string, RouteConfig>>((acc, config) => {\n    // NOTE(EvanBacon): Uses the regex pattern as key to detect duplicate slugs.\n    const indexedKey = config.regex?.toString() ?? config.pattern;\n    const alpha = acc[indexedKey];\n    // NOTE(EvanBacon): Skips checking nodes that have children.\n    if (alpha && !alpha.hasChildren && !config.hasChildren) {\n      const a = alpha.routeNames;\n      const b = config.routeNames;\n\n      // It's not a problem if the path string omitted from a inner most screen\n      // For example, it's ok if a path resolves to `A > B > C` or `A > B`\n      const intersects =\n        a.length > b.length ? b.every((it, i) => a[i] === it) : a.every((it, i) => b[i] === it);\n\n      if (!intersects) {\n        // NOTE(EvanBacon): Adds more context to the error message since we know about the\n        // file-based routing.\n        const last = config.pattern.split('/').pop();\n\n        if (!last?.match(/^\\*not-found$/)) {\n          const routeType = last?.startsWith(':')\n            ? 'dynamic route'\n            : last?.startsWith('*')\n              ? 'dynamic-rest route'\n              : 'route';\n          throw new Error(\n            `The ${routeType} pattern '${config.pattern || '/'}' resolves to both '${\n              alpha.userReadableName\n            }' and '${\n              config.userReadableName\n            }'. Patterns must be unique and cannot resolve to more than one route.`\n          );\n        }\n      }\n    }\n\n    return Object.assign(acc, {\n      [indexedKey]: config,\n    });\n  }, {});\n}\n\nfunction sortConfigs(a: RouteConfig, b: RouteConfig): number {\n  // Sort config so that:\n  // - the most exhaustive ones are always at the beginning\n  // - patterns with wildcard are always at the end\n\n  // If 2 patterns are same, move the one with less route names up\n  // This is an error state, so it's only useful for consistent error messages\n  if (a.pattern === b.pattern) {\n    return b.routeNames.join('>').localeCompare(a.routeNames.join('>'));\n  }\n\n  // If one of the patterns starts with the other, it's more exhaustive\n  // So move it up\n  if (\n    a.pattern.startsWith(b.pattern) &&\n    // NOTE(EvanBacon): This is a hack to make sure that `*` is always at the end\n    b.screen !== 'index'\n  ) {\n    return -1;\n  }\n\n  if (b.pattern.startsWith(a.pattern) && a.screen !== 'index') {\n    return 1;\n  }\n\n  // NOTE(EvanBacon): Here we append `index` if the screen was `index` so the length is the same\n  // as a slug or wildcard when nested more than one level deep.\n  // This is so we can compare the length of the pattern, e.g. `foo/*` > `foo` vs `*` < ``.\n  const aParts = a.pattern\n    .split('/')\n    // Strip out group names to ensure they don't affect the priority.\n    .filter((part) => matchGroupName(part) == null);\n  if (a.screen === 'index') {\n    aParts.push('index');\n  }\n\n  const bParts = b.pattern.split('/').filter((part) => matchGroupName(part) == null);\n  if (b.screen === 'index') {\n    bParts.push('index');\n  }\n\n  for (let i = 0; i < Math.max(aParts.length, bParts.length); i++) {\n    // if b is longer, b get higher priority\n    if (aParts[i] == null) {\n      return 1;\n    }\n    // if a is longer, a get higher priority\n    if (bParts[i] == null) {\n      return -1;\n    }\n\n    const aWildCard = aParts[i].startsWith('*');\n    const bWildCard = bParts[i].startsWith('*');\n    // if both are wildcard we compare next component\n    if (aWildCard && bWildCard) {\n      const aNotFound = aParts[i].match(/^[*]not-found$/);\n      const bNotFound = bParts[i].match(/^[*]not-found$/);\n\n      if (aNotFound && bNotFound) {\n        continue;\n      } else if (aNotFound) {\n        return 1;\n      } else if (bNotFound) {\n        return -1;\n      }\n      continue;\n    }\n    // if only a is wild card, b get higher priority\n    if (aWildCard) {\n      return 1;\n    }\n    // if only b is wild card, a get higher priority\n    if (bWildCard) {\n      return -1;\n    }\n\n    const aSlug = aParts[i].startsWith(':');\n    const bSlug = bParts[i].startsWith(':');\n    // if both are wildcard we compare next component\n    if (aSlug && bSlug) {\n      const aNotFound = aParts[i].match(/^[*]not-found$/);\n      const bNotFound = bParts[i].match(/^[*]not-found$/);\n\n      if (aNotFound && bNotFound) {\n        continue;\n      } else if (aNotFound) {\n        return 1;\n      } else if (bNotFound) {\n        return -1;\n      }\n\n      continue;\n    }\n    // if only a is wild card, b get higher priority\n    if (aSlug) {\n      return 1;\n    }\n    // if only b is wild card, a get higher priority\n    if (bSlug) {\n      return -1;\n    }\n  }\n\n  // Sort initial routes with a higher priority than routes which will push more screens\n  // this ensures shared routes go to the shortest path.\n  if (a.isInitial && !b.isInitial) {\n    return -1;\n  }\n  if (!a.isInitial && b.isInitial) {\n    return 1;\n  }\n\n  return bParts.length - aParts.length;\n}\n\nfunction getStateFromEmptyPathWithConfigs(\n  path: string,\n  configs: RouteConfig[],\n  initialRoutes: InitialRouteConfig[]\n): ResultState | undefined {\n  // We need to add special handling of empty path so navigation to empty path also works\n  // When handling empty path, we should only look at the root level config\n\n  // NOTE(EvanBacon): We only care about matching leaf nodes.\n  const leafNodes = configs\n    .filter((config) => !config.hasChildren)\n    .map((value) => {\n      return {\n        ...value,\n        // Collapse all levels of group segments before testing.\n        // This enables `app/(one)/(two)/index.js` to be matched.\n        path: stripGroupSegmentsFromPath(value.path),\n      };\n    });\n\n  const match =\n    leafNodes.find(\n      (config) =>\n        // NOTE(EvanBacon): Test leaf node index routes that either don't have a regex or match an empty string.\n        config.path === '' && (!config.regex || config.regex.test(''))\n    ) ??\n    leafNodes.find(\n      (config) =>\n        // NOTE(EvanBacon): Test leaf node dynamic routes that match an empty string.\n        config.path.startsWith(':') && config.regex!.test('')\n    ) ??\n    // NOTE(EvanBacon): Test leaf node deep dynamic routes that match a slash.\n    // This should be done last to enable dynamic routes having a higher priority.\n    leafNodes.find((config) => config.path.startsWith('*') && config.regex!.test('/'));\n\n  if (!match) {\n    return undefined;\n  }\n\n  const routes = match.routeNames.map((name) => {\n    if (!match._route) {\n      return { name };\n    }\n    return {\n      name,\n      _route: match._route,\n    };\n  });\n\n  return createNestedStateObject(path, routes, configs, initialRoutes);\n}\n\nfunction getStateFromPathWithConfigs(\n  path: string,\n  configs: RouteConfig[],\n  initialRoutes: InitialRouteConfig[],\n  baseUrl: string | undefined = process.env.EXPO_BASE_URL\n): ResultState | undefined {\n  const formattedPaths = getUrlWithReactNavigationConcessions(path);\n\n  if (!formattedPaths.url) return;\n\n  let cleanPath =\n    stripBaseUrl(stripGroupSegmentsFromPath(formattedPaths.url.pathname), baseUrl) +\n    formattedPaths.url.search;\n\n  if (!path.startsWith('/')) cleanPath = cleanPath.slice(1);\n\n  if (formattedPaths.nonstandardPathname === '/') {\n    return getStateFromEmptyPathWithConfigs(cleanPath, configs, initialRoutes);\n  }\n\n  // We match the whole path against the regex instead of segments\n  // This makes sure matches such as wildcard will catch any unmatched routes, even if nested\n  const routes = matchAgainstConfigs(formattedPaths.nonstandardPathname, configs);\n\n  if (routes == null) {\n    return undefined;\n  }\n  // This will always be empty if full path matched\n  return createNestedStateObject(cleanPath, routes, configs, initialRoutes);\n}\n\nconst joinPaths = (...paths: string[]): string =>\n  ([] as string[])\n    .concat(...paths.map((p) => p.split('/')))\n    .filter(Boolean)\n    .join('/');\n\nfunction matchAgainstConfigs(remaining: string, configs: RouteConfig[]): ParsedRoute[] | undefined {\n  let routes: ParsedRoute[] | undefined;\n  let remainingPath = remaining;\n\n  // Go through all configs, and see if the next path segment matches our regex\n  for (const config of configs) {\n    if (!config.regex) {\n      continue;\n    }\n\n    const match = remainingPath.match(config.regex);\n\n    // If our regex matches, we need to extract params from the path\n    if (!match) {\n      continue;\n    }\n\n    // TODO: Add support for wildcard routes\n    const matchedParams = config.pattern\n      ?.split('/')\n      .filter((p) => p.match(/^[:*]/))\n      .reduce<Record<string, any>>((acc, p, i) => {\n        if (p.match(/^\\*/)) {\n          return {\n            ...acc,\n            [p]: match![(i + 1) * 2], //?.replace(/\\//, \"\"),\n          };\n        }\n        return Object.assign(acc, {\n          // The param segments appear every second item starting from 2 in the regex match result.\n          // This will only work if we ensure groups aren't included in the match.\n          [p]: match![(i + 1) * 2]?.replace(/\\//, ''),\n        });\n      }, {});\n\n    const routeFromName = (name: string) => {\n      const config = configs.find((c) => c.screen === name);\n      if (!config?.path) {\n        return { name };\n      }\n\n      const segments = config.path.split('/');\n\n      const params: Record<string, any> = {};\n\n      segments\n        .filter((p) => p.match(/^[:*]/))\n        .forEach((p) => {\n          let value = matchedParams[p];\n          if (value) {\n            if (p.match(/^\\*/)) {\n              // Convert to an array before providing as a route.\n              value = value?.split('/').filter(Boolean);\n            }\n\n            const key = p.replace(/^[:*]/, '').replace(/\\?$/, '');\n            params[key] = config.parse?.[key] ? config.parse[key](value) : value;\n          }\n        });\n\n      if (params && Object.keys(params).length) {\n        return { name, params };\n      }\n\n      return { name };\n    };\n\n    routes = config.routeNames.map((name) => {\n      if (!config._route) {\n        return { ...routeFromName(name) };\n      }\n      return {\n        ...routeFromName(name),\n        _route: config._route,\n      };\n    });\n\n    // TODO(EvanBacon): Maybe we should warn / assert if multiple slugs use the same param name.\n    const combinedParams = routes.reduce<Record<string, any>>(\n      (acc, r) => Object.assign(acc, r.params),\n      {}\n    );\n\n    const hasCombinedParams = Object.keys(combinedParams).length > 0;\n\n    // Combine all params so a route `[foo]/[bar]/other.js` has access to `{ foo, bar }`\n    routes = routes.map((r) => {\n      if (hasCombinedParams) {\n        r.params = combinedParams;\n      }\n      return r;\n    });\n\n    remainingPath = remainingPath.replace(match[1], '');\n\n    break;\n  }\n\n  return routes;\n}\n\nfunction equalHeritage(a: string[], b: string[]): boolean {\n  if (a.length !== b.length) {\n    return false;\n  }\n  for (let i = 0; i < a.length; i++) {\n    if (a[i].localeCompare(b[i]) !== 0) {\n      return false;\n    }\n  }\n  return true;\n}\n\nconst createNormalizedConfigs = (\n  screen: string,\n  routeConfig: PathConfigMap<object>,\n  routeNames: string[] = [],\n  initials: InitialRouteConfig[] = [],\n  parentScreens: string[] = [],\n  parentPattern?: string\n): RouteConfig[] => {\n  const configs: RouteConfig[] = [];\n\n  routeNames.push(screen);\n\n  parentScreens.push(screen);\n\n  const config = (routeConfig as any)[screen];\n\n  if (typeof config === 'string') {\n    // TODO: This should never happen with the addition of `_route`\n\n    // If a string is specified as the value of the key(e.g. Foo: '/path'), use it as the pattern\n    const pattern = parentPattern ? joinPaths(parentPattern, config) : config;\n\n    configs.push(createConfigItem(screen, routeNames, pattern, config, false));\n  } else if (typeof config === 'object') {\n    let pattern: string | undefined;\n\n    const { _route } = config;\n    // if an object is specified as the value (e.g. Foo: { ... }),\n    // it can have `path` property and\n    // it could have `screens` prop which has nested configs\n    if (typeof config.path === 'string') {\n      if (config.exact && config.path === undefined) {\n        throw new Error(\n          \"A 'path' needs to be specified when specifying 'exact: true'. If you don't want this screen in the URL, specify it as empty string, e.g. `path: ''`.\"\n        );\n      }\n\n      pattern =\n        config.exact !== true\n          ? joinPaths(parentPattern || '', config.path || '')\n          : config.path || '';\n\n      configs.push(\n        createConfigItem(\n          screen,\n          routeNames,\n          pattern!,\n          config.path,\n          config.screens ? !!Object.keys(config.screens)?.length : false,\n          config.parse,\n          _route\n        )\n      );\n    }\n\n    if (config.screens) {\n      // property `initialRouteName` without `screens` has no purpose\n      if (config.initialRouteName) {\n        initials.push({\n          initialRouteName: config.initialRouteName,\n          parentScreens,\n        });\n      }\n\n      Object.keys(config.screens).forEach((nestedConfig) => {\n        const result = createNormalizedConfigs(\n          nestedConfig,\n          config.screens as PathConfigMap<object>,\n          routeNames,\n          initials,\n          [...parentScreens],\n          pattern ?? parentPattern\n        );\n\n        configs.push(...result);\n      });\n    }\n  }\n\n  routeNames.pop();\n\n  return configs;\n};\n\nfunction formatRegexPattern(it: string): string {\n  // Allow spaces in file path names.\n  it = it.replace(' ', '%20');\n\n  if (it.startsWith(':')) {\n    // TODO: Remove unused match group\n    return `(([^/]+\\\\/)${it.endsWith('?') ? '?' : ''})`;\n  } else if (it.startsWith('*')) {\n    return `((.*\\\\/)${it.endsWith('?') ? '?' : ''})`;\n  }\n\n  // Strip groups from the matcher\n  if (matchGroupName(it) != null) {\n    // Groups are optional segments\n    // this enables us to match `/bar` and `/(foo)/bar` for the same route\n    // NOTE(EvanBacon): Ignore this match in the regex to avoid capturing the group\n    return `(?:${escape(it)}\\\\/)?`;\n  }\n\n  return escape(it) + `\\\\/`;\n}\n\nconst createConfigItem = (\n  screen: string,\n  routeNames: string[],\n  pattern: string,\n  path: string,\n  hasChildren?: boolean,\n  parse?: ParseConfig,\n  _route?: any\n): RouteConfig => {\n  // Normalize pattern to remove any leading, trailing slashes, duplicate slashes etc.\n  pattern = pattern.split('/').filter(Boolean).join('/');\n\n  const regex = pattern\n    ? new RegExp(`^(${pattern.split('/').map(formatRegexPattern).join('')})$`)\n    : undefined;\n\n  return {\n    screen,\n    regex,\n    pattern,\n    path,\n    // The routeNames array is mutated, so copy it to keep the current state\n    routeNames: [...routeNames],\n    parse,\n    userReadableName: [...routeNames.slice(0, -1), path || screen].join('/'),\n    hasChildren: !!hasChildren,\n    _route,\n  };\n};\n\nconst findParseConfigForRoute = (\n  routeName: string,\n  routeConfigs: RouteConfig[]\n): ParseConfig | undefined => {\n  for (const config of routeConfigs) {\n    if (routeName === config.routeNames[config.routeNames.length - 1]) {\n      return config.parse;\n    }\n  }\n\n  return undefined;\n};\n\n// Try to find an initial route connected with the one passed\nconst findInitialRoute = (\n  routeName: string,\n  parentScreens: string[],\n  initialRoutes: InitialRouteConfig[]\n): string | undefined => {\n  for (const config of initialRoutes) {\n    if (equalHeritage(parentScreens, config.parentScreens)) {\n      // If the parents are the same but the route name doesn't match the initial route\n      // then we return the initial route.\n      return routeName !== config.initialRouteName ? config.initialRouteName : undefined;\n    }\n  }\n  return undefined;\n};\n\n// returns state object with values depending on whether\n// it is the end of state and if there is initialRoute for this level\nconst createStateObject = (\n  route: ParsedRoute,\n  isEmpty: boolean,\n  initialRoute?: string\n): InitialState => {\n  if (isEmpty) {\n    if (initialRoute) {\n      return {\n        index: 1,\n        routes: [{ name: initialRoute }, route],\n      };\n    }\n    return {\n      routes: [route],\n    };\n  }\n\n  if (initialRoute) {\n    return {\n      index: 1,\n      routes: [{ name: initialRoute }, { ...route, state: { routes: [] } }],\n    };\n  }\n  return {\n    routes: [{ ...route, state: { routes: [] } }],\n  };\n};\n\nconst createNestedStateObject = (\n  path: string,\n  routes: ParsedRoute[],\n  routeConfigs: RouteConfig[],\n  initialRoutes: InitialRouteConfig[]\n) => {\n  let route = routes.shift() as ParsedRoute;\n  const parentScreens: string[] = [];\n\n  let initialRoute = findInitialRoute(route.name, parentScreens, initialRoutes);\n\n  parentScreens.push(route.name);\n\n  const state: InitialState = createStateObject(route, routes.length === 0, initialRoute);\n\n  if (routes.length > 0) {\n    let nestedState = state;\n\n    while ((route = routes.shift() as ParsedRoute)) {\n      initialRoute = findInitialRoute(route.name, parentScreens, initialRoutes);\n\n      const nestedStateIndex = nestedState.index || nestedState.routes.length - 1;\n\n      nestedState.routes[nestedStateIndex].state = createStateObject(\n        route,\n        routes.length === 0,\n        initialRoute\n      );\n\n      if (routes.length > 0) {\n        nestedState = nestedState.routes[nestedStateIndex].state as InitialState;\n      }\n\n      parentScreens.push(route.name);\n    }\n  }\n\n  route = findFocusedRoute(state) as ParsedRoute;\n\n  // Remove groups from the path while preserving a trailing slash.\n  route.path = path;\n\n  const params = parseQueryParams(route.path, findParseConfigForRoute(route.name, routeConfigs));\n\n  if (params) {\n    route.params = Object.assign(Object.create(null), route.params) as Record<string, any>;\n    for (const [name, value] of Object.entries(params)) {\n      if (route.params?.[name]) {\n        if (process.env.NODE_ENV !== 'production') {\n          console.warn(\n            `Route '/${route.name}' with param '${name}' was specified both in the path and as a param, removing from path`\n          );\n        }\n      }\n\n      if (!route.params?.[name]) {\n        route.params[name] = value;\n        continue;\n      }\n    }\n\n    if (Object.keys(route.params).length === 0) {\n      delete route.params;\n    }\n  }\n\n  return state;\n};\n\nconst parseQueryParams = (path: string, parseConfig?: Record<string, (value: string) => any>) => {\n  const query = path.split('?')[1];\n  const searchParams = new URLSearchParams(query);\n  const params = Object.fromEntries(\n    // @ts-ignore: [Symbol.iterator] is indeed, available on every platform.\n    searchParams\n  );\n\n  if (parseConfig) {\n    Object.keys(params).forEach((name) => {\n      if (Object.hasOwnProperty.call(parseConfig, name) && typeof params[name] === 'string') {\n        params[name] = parseConfig[name](params[name] as string);\n      }\n    });\n  }\n\n  return Object.keys(params).length ? params : undefined;\n};\n\nconst baseUrlCache = new Map<string, RegExp>();\n\nfunction getBaseUrlRegex(baseUrl: string) {\n  if (baseUrlCache.has(baseUrl)) {\n    return baseUrlCache.get(baseUrl)!;\n  }\n  const regex = new RegExp(`^\\\\/?${escape(baseUrl)}`, 'g');\n  baseUrlCache.set(baseUrl, regex);\n  return regex;\n}\n\nexport function stripBaseUrl(\n  path: string,\n  baseUrl: string | undefined = process.env.EXPO_BASE_URL\n) {\n  if (process.env.NODE_ENV !== 'development') {\n    if (baseUrl) {\n      const reg = getBaseUrlRegex(baseUrl);\n      return path.replace(/^\\/+/g, '/').replace(reg, '');\n    }\n  }\n  return path;\n}\n"],"mappings":";;;;;;;;;AAEA,SAAAA,oBAAA;EAAA,MAAAC,IAAA,GAAAC,sBAAA,CAAAC,OAAA;EAAAH,mBAAA,YAAAA,CAAA;IAAA,OAAAC,IAAA;EAAA;EAAA,OAAAA,IAAA;AAAA;AAEA,SAAAG,kBAAA;EAAA,MAAAH,IAAA,GAAAE,OAAA;EAAAC,iBAAA,YAAAA,CAAA;IAAA,OAAAH,IAAA;EAAA;EAAA,OAAAA,IAAA;AAAA;AACA,SAAAI,oBAAA;EAAA,MAAAJ,IAAA,GAAAC,sBAAA,CAAAC,OAAA;EAAAE,mBAAA,YAAAA,CAAA;IAAA,OAAAJ,IAAA;EAAA;EAAA,OAAAA,IAAA;AAAA;AAEA,SAAAK,UAAA;EAAA,MAAAL,IAAA,GAAAE,OAAA;EAAAG,SAAA,YAAAA,CAAA;IAAA,OAAAL,IAAA;EAAA;EAAA,OAAAA,IAAA;AAAA;AAAyE,SAAAC,uBAAAK,GAAA,WAAAA,GAAA,IAAAA,GAAA,CAAAC,UAAA,GAAAD,GAAA,KAAAE,OAAA,EAAAF,GAAA;AAqClE,SAASG,oCAAoCA,CAClDC,IAAY,EACZC,OAA2B,GAAGC,OAAO,CAACC,GAAG,CAACC,aAAa,EACvD;EACA,IAAIC,MAAW;EACf,IAAI;IACFA,MAAM,GAAG,IAAIC,GAAG,CAACN,IAAI,EAAE,uBAAuB,CAAC;EACjD,CAAC,CAAC,MAAM;IACN;IACA,OAAO;MACLO,mBAAmB,EAAE,EAAE;MACvBC,wBAAwB,EAAE,EAAE;MAC5BC,GAAG,EAAE;IACP,CAAC;EACH;EAEA,MAAMC,QAAQ,GAAGL,MAAM,CAACK,QAAQ;;EAEhC;EACA,OAAO;IACL;IACAH,mBAAmB,EACjBI,YAAY,CAACD,QAAQ,EAAET,OAAO,CAAC,CAACW,OAAO,CAAC,OAAO,EAAE,EAAE,CAAC,CAACA,OAAO,CAAC,OAAO,EAAE,EAAE,CAAC,GAAG,GAAG;IAEjF;IACAJ,wBAAwB,EAAEG,YAAY,CAACX,IAAI,EAAEC,OAAO,CAAC,CAACW,OAAO,CAAC,MAAM,EAAE,EAAE,CAAC;IACzEH,GAAG,EAAEJ;EACP,CAAC;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe,SAASQ,gBAAgBA,CACtCb,IAAY,EACZc,OAA4B,EACH;EACzB,MAAM;IAAEC,aAAa;IAAEC;EAAQ,CAAC,GAAGC,wBAAwB,CAACH,OAAO,CAAC;EAEpE,OAAOI,2BAA2B,CAAClB,IAAI,EAAEgB,OAAO,EAAED,aAAa,CAAC;AAClE;AAEO,SAASE,wBAAwBA,CAA2BH,OAA4B,EAAE;EAC/F,IAAIA,OAAO,EAAE;IACX,IAAAK,6BAAkB,EAACL,OAAO,CAAC;EAC7B;EAEA,MAAMM,OAAO,GAAGN,OAAO,EAAEM,OAAO;EAChC;EACA,IAAI,CAACA,OAAO,EAAE;IACZ,MAAMC,KAAK,CAAC,4EAA4E,CAAC;EAC3F;;EAEA;EACA,MAAMN,aAAmC,GAAG,EAAE;EAE9C,IAAID,OAAO,EAAEQ,gBAAgB,EAAE;IAC7BP,aAAa,CAACQ,IAAI,CAAC;MACjBD,gBAAgB,EAAER,OAAO,CAACQ,gBAAgB;MAC1CE,aAAa,EAAE;IACjB,CAAC,CAAC;EACJ;;EAEA;EACA,MAAMC,SAAS,GAAGC,MAAM,CAACC,IAAI,CAACP,OAAO,CAAC,CACnCQ,GAAG,CAAEC,GAAG,IAAKC,uBAAuB,CAACD,GAAG,EAAET,OAAO,EAAE,EAAE,EAAEL,aAAa,CAAC,CAAC,CACtEgB,IAAI,CAAC,CAAC;EAET,MAAMC,uBAAuB,GAAGjB,aAAa,CAACa,GAAG,CAAEK,KAAK,IACtDC,SAAS,CAAC,GAAGD,KAAK,CAACT,aAAa,EAAES,KAAK,CAACX,gBAAgB,CAC1D,CAAC;EAED,MAAMa,oBAAoB,GAAGV,SAAS,CAACG,GAAG,CAAEQ,MAAM,KAAM;IACtD,GAAGA,MAAM;IACT;IACA;IACAC,SAAS,EAAEL,uBAAuB,CAACM,QAAQ,CAACF,MAAM,CAACG,UAAU,CAACC,IAAI,CAAC,GAAG,CAAC;EACzE,CAAC,CAAC,CAAC;;EAEH;EACA,MAAMxB,OAAO,GAAGmB,oBAAoB,CAACM,IAAI,CAACC,WAAW,CAAC;;EAEtD;EACAC,sBAAsB,CAAC3B,OAAO,CAAC;EAE/B,OAAO;IAAEA,OAAO;IAAED;EAAc,CAAC;AACnC;AAEA,SAAS4B,sBAAsBA,CAAC3B,OAAsB,EAAE;EACtD;EACAA,OAAO,CAAC4B,MAAM,CAA8B,CAACC,GAAG,EAAET,MAAM,KAAK;IAC3D;IACA,MAAMU,UAAU,GAAGV,MAAM,CAACW,KAAK,EAAEC,QAAQ,CAAC,CAAC,IAAIZ,MAAM,CAACa,OAAO;IAC7D,MAAMC,KAAK,GAAGL,GAAG,CAACC,UAAU,CAAC;IAC7B;IACA,IAAII,KAAK,IAAI,CAACA,KAAK,CAACC,WAAW,IAAI,CAACf,MAAM,CAACe,WAAW,EAAE;MACtD,MAAMC,CAAC,GAAGF,KAAK,CAACX,UAAU;MAC1B,MAAMc,CAAC,GAAGjB,MAAM,CAACG,UAAU;;MAE3B;MACA;MACA,MAAMe,UAAU,GACdF,CAAC,CAACG,MAAM,GAAGF,CAAC,CAACE,MAAM,GAAGF,CAAC,CAACG,KAAK,CAAC,CAACC,EAAE,EAAEC,CAAC,KAAKN,CAAC,CAACM,CAAC,CAAC,KAAKD,EAAE,CAAC,GAAGL,CAAC,CAACI,KAAK,CAAC,CAACC,EAAE,EAAEC,CAAC,KAAKL,CAAC,CAACK,CAAC,CAAC,KAAKD,EAAE,CAAC;MAEzF,IAAI,CAACH,UAAU,EAAE;QACf;QACA;QACA,MAAMK,IAAI,GAAGvB,MAAM,CAACa,OAAO,CAACW,KAAK,CAAC,GAAG,CAAC,CAACC,GAAG,CAAC,CAAC;QAE5C,IAAI,CAACF,IAAI,EAAEG,KAAK,CAAC,eAAe,CAAC,EAAE;UACjC,MAAMC,SAAS,GAAGJ,IAAI,EAAEK,UAAU,CAAC,GAAG,CAAC,GACnC,eAAe,GACfL,IAAI,EAAEK,UAAU,CAAC,GAAG,CAAC,GACnB,oBAAoB,GACpB,OAAO;UACb,MAAM,IAAI3C,KAAK,CACZ,OAAM0C,SAAU,aAAY3B,MAAM,CAACa,OAAO,IAAI,GAAI,uBACjDC,KAAK,CAACe,gBACP,UACC7B,MAAM,CAAC6B,gBACR,uEACH,CAAC;QACH;MACF;IACF;IAEA,OAAOvC,MAAM,CAACwC,MAAM,CAACrB,GAAG,EAAE;MACxB,CAACC,UAAU,GAAGV;IAChB,CAAC,CAAC;EACJ,CAAC,EAAE,CAAC,CAAC,CAAC;AACR;AAEA,SAASM,WAAWA,CAACU,CAAc,EAAEC,CAAc,EAAU;EAC3D;EACA;EACA;;EAEA;EACA;EACA,IAAID,CAAC,CAACH,OAAO,KAAKI,CAAC,CAACJ,OAAO,EAAE;IAC3B,OAAOI,CAAC,CAACd,UAAU,CAACC,IAAI,CAAC,GAAG,CAAC,CAAC2B,aAAa,CAACf,CAAC,CAACb,UAAU,CAACC,IAAI,CAAC,GAAG,CAAC,CAAC;EACrE;;EAEA;EACA;EACA,IACEY,CAAC,CAACH,OAAO,CAACe,UAAU,CAACX,CAAC,CAACJ,OAAO,CAAC;EAC/B;EACAI,CAAC,CAACe,MAAM,KAAK,OAAO,EACpB;IACA,OAAO,CAAC,CAAC;EACX;EAEA,IAAIf,CAAC,CAACJ,OAAO,CAACe,UAAU,CAACZ,CAAC,CAACH,OAAO,CAAC,IAAIG,CAAC,CAACgB,MAAM,KAAK,OAAO,EAAE;IAC3D,OAAO,CAAC;EACV;;EAEA;EACA;EACA;EACA,MAAMC,MAAM,GAAGjB,CAAC,CAACH,OAAO,CACrBW,KAAK,CAAC,GAAG;EACV;EAAA,CACCU,MAAM,CAAEC,IAAI,IAAK,IAAAC,0BAAc,EAACD,IAAI,CAAC,IAAI,IAAI,CAAC;EACjD,IAAInB,CAAC,CAACgB,MAAM,KAAK,OAAO,EAAE;IACxBC,MAAM,CAAC9C,IAAI,CAAC,OAAO,CAAC;EACtB;EAEA,MAAMkD,MAAM,GAAGpB,CAAC,CAACJ,OAAO,CAACW,KAAK,CAAC,GAAG,CAAC,CAACU,MAAM,CAAEC,IAAI,IAAK,IAAAC,0BAAc,EAACD,IAAI,CAAC,IAAI,IAAI,CAAC;EAClF,IAAIlB,CAAC,CAACe,MAAM,KAAK,OAAO,EAAE;IACxBK,MAAM,CAAClD,IAAI,CAAC,OAAO,CAAC;EACtB;EAEA,KAAK,IAAImC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGgB,IAAI,CAACC,GAAG,CAACN,MAAM,CAACd,MAAM,EAAEkB,MAAM,CAAClB,MAAM,CAAC,EAAEG,CAAC,EAAE,EAAE;IAC/D;IACA,IAAIW,MAAM,CAACX,CAAC,CAAC,IAAI,IAAI,EAAE;MACrB,OAAO,CAAC;IACV;IACA;IACA,IAAIe,MAAM,CAACf,CAAC,CAAC,IAAI,IAAI,EAAE;MACrB,OAAO,CAAC,CAAC;IACX;IAEA,MAAMkB,SAAS,GAAGP,MAAM,CAACX,CAAC,CAAC,CAACM,UAAU,CAAC,GAAG,CAAC;IAC3C,MAAMa,SAAS,GAAGJ,MAAM,CAACf,CAAC,CAAC,CAACM,UAAU,CAAC,GAAG,CAAC;IAC3C;IACA,IAAIY,SAAS,IAAIC,SAAS,EAAE;MAC1B,MAAMC,SAAS,GAAGT,MAAM,CAACX,CAAC,CAAC,CAACI,KAAK,CAAC,gBAAgB,CAAC;MACnD,MAAMiB,SAAS,GAAGN,MAAM,CAACf,CAAC,CAAC,CAACI,KAAK,CAAC,gBAAgB,CAAC;MAEnD,IAAIgB,SAAS,IAAIC,SAAS,EAAE;QAC1B;MACF,CAAC,MAAM,IAAID,SAAS,EAAE;QACpB,OAAO,CAAC;MACV,CAAC,MAAM,IAAIC,SAAS,EAAE;QACpB,OAAO,CAAC,CAAC;MACX;MACA;IACF;IACA;IACA,IAAIH,SAAS,EAAE;MACb,OAAO,CAAC;IACV;IACA;IACA,IAAIC,SAAS,EAAE;MACb,OAAO,CAAC,CAAC;IACX;IAEA,MAAMG,KAAK,GAAGX,MAAM,CAACX,CAAC,CAAC,CAACM,UAAU,CAAC,GAAG,CAAC;IACvC,MAAMiB,KAAK,GAAGR,MAAM,CAACf,CAAC,CAAC,CAACM,UAAU,CAAC,GAAG,CAAC;IACvC;IACA,IAAIgB,KAAK,IAAIC,KAAK,EAAE;MAClB,MAAMH,SAAS,GAAGT,MAAM,CAACX,CAAC,CAAC,CAACI,KAAK,CAAC,gBAAgB,CAAC;MACnD,MAAMiB,SAAS,GAAGN,MAAM,CAACf,CAAC,CAAC,CAACI,KAAK,CAAC,gBAAgB,CAAC;MAEnD,IAAIgB,SAAS,IAAIC,SAAS,EAAE;QAC1B;MACF,CAAC,MAAM,IAAID,SAAS,EAAE;QACpB,OAAO,CAAC;MACV,CAAC,MAAM,IAAIC,SAAS,EAAE;QACpB,OAAO,CAAC,CAAC;MACX;MAEA;IACF;IACA;IACA,IAAIC,KAAK,EAAE;MACT,OAAO,CAAC;IACV;IACA;IACA,IAAIC,KAAK,EAAE;MACT,OAAO,CAAC,CAAC;IACX;EACF;;EAEA;EACA;EACA,IAAI7B,CAAC,CAACf,SAAS,IAAI,CAACgB,CAAC,CAAChB,SAAS,EAAE;IAC/B,OAAO,CAAC,CAAC;EACX;EACA,IAAI,CAACe,CAAC,CAACf,SAAS,IAAIgB,CAAC,CAAChB,SAAS,EAAE;IAC/B,OAAO,CAAC;EACV;EAEA,OAAOoC,MAAM,CAAClB,MAAM,GAAGc,MAAM,CAACd,MAAM;AACtC;AAEA,SAAS2B,gCAAgCA,CACvClF,IAAY,EACZgB,OAAsB,EACtBD,aAAmC,EACV;EACzB;EACA;;EAEA;EACA,MAAMoE,SAAS,GAAGnE,OAAO,CACtBsD,MAAM,CAAElC,MAAM,IAAK,CAACA,MAAM,CAACe,WAAW,CAAC,CACvCvB,GAAG,CAAEwD,KAAK,IAAK;IACd,OAAO;MACL,GAAGA,KAAK;MACR;MACA;MACApF,IAAI,EAAE,IAAAqF,sCAA0B,EAACD,KAAK,CAACpF,IAAI;IAC7C,CAAC;EACH,CAAC,CAAC;EAEJ,MAAM8D,KAAK,GACTqB,SAAS,CAACG,IAAI,CACXlD,MAAM;EACL;EACAA,MAAM,CAACpC,IAAI,KAAK,EAAE,KAAK,CAACoC,MAAM,CAACW,KAAK,IAAIX,MAAM,CAACW,KAAK,CAACwC,IAAI,CAAC,EAAE,CAAC,CACjE,CAAC,IACDJ,SAAS,CAACG,IAAI,CACXlD,MAAM;EACL;EACAA,MAAM,CAACpC,IAAI,CAACgE,UAAU,CAAC,GAAG,CAAC,IAAI5B,MAAM,CAACW,KAAK,CAAEwC,IAAI,CAAC,EAAE,CACxD,CAAC;EACD;EACA;EACAJ,SAAS,CAACG,IAAI,CAAElD,MAAM,IAAKA,MAAM,CAACpC,IAAI,CAACgE,UAAU,CAAC,GAAG,CAAC,IAAI5B,MAAM,CAACW,KAAK,CAAEwC,IAAI,CAAC,GAAG,CAAC,CAAC;EAEpF,IAAI,CAACzB,KAAK,EAAE;IACV,OAAO0B,SAAS;EAClB;EAEA,MAAMC,MAAM,GAAG3B,KAAK,CAACvB,UAAU,CAACX,GAAG,CAAE8D,IAAI,IAAK;IAC5C,IAAI,CAAC5B,KAAK,CAAC6B,MAAM,EAAE;MACjB,OAAO;QAAED;MAAK,CAAC;IACjB;IACA,OAAO;MACLA,IAAI;MACJC,MAAM,EAAE7B,KAAK,CAAC6B;IAChB,CAAC;EACH,CAAC,CAAC;EAEF,OAAOC,uBAAuB,CAAC5F,IAAI,EAAEyF,MAAM,EAAEzE,OAAO,EAAED,aAAa,CAAC;AACtE;AAEA,SAASG,2BAA2BA,CAClClB,IAAY,EACZgB,OAAsB,EACtBD,aAAmC,EACnCd,OAA2B,GAAGC,OAAO,CAACC,GAAG,CAACC,aAAa,EAC9B;EACzB,MAAMyF,cAAc,GAAG9F,oCAAoC,CAACC,IAAI,CAAC;EAEjE,IAAI,CAAC6F,cAAc,CAACpF,GAAG,EAAE;EAEzB,IAAIqF,SAAS,GACXnF,YAAY,CAAC,IAAA0E,sCAA0B,EAACQ,cAAc,CAACpF,GAAG,CAACC,QAAQ,CAAC,EAAET,OAAO,CAAC,GAC9E4F,cAAc,CAACpF,GAAG,CAACsF,MAAM;EAE3B,IAAI,CAAC/F,IAAI,CAACgE,UAAU,CAAC,GAAG,CAAC,EAAE8B,SAAS,GAAGA,SAAS,CAACE,KAAK,CAAC,CAAC,CAAC;EAEzD,IAAIH,cAAc,CAACtF,mBAAmB,KAAK,GAAG,EAAE;IAC9C,OAAO2E,gCAAgC,CAACY,SAAS,EAAE9E,OAAO,EAAED,aAAa,CAAC;EAC5E;;EAEA;EACA;EACA,MAAM0E,MAAM,GAAGQ,mBAAmB,CAACJ,cAAc,CAACtF,mBAAmB,EAAES,OAAO,CAAC;EAE/E,IAAIyE,MAAM,IAAI,IAAI,EAAE;IAClB,OAAOD,SAAS;EAClB;EACA;EACA,OAAOI,uBAAuB,CAACE,SAAS,EAAEL,MAAM,EAAEzE,OAAO,EAAED,aAAa,CAAC;AAC3E;AAEA,MAAMmB,SAAS,GAAGA,CAAC,GAAGgE,KAAe,KAClC,EAAE,CACAC,MAAM,CAAC,GAAGD,KAAK,CAACtE,GAAG,CAAEwE,CAAC,IAAKA,CAAC,CAACxC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CACzCU,MAAM,CAAC+B,OAAO,CAAC,CACf7D,IAAI,CAAC,GAAG,CAAC;AAEd,SAASyD,mBAAmBA,CAACK,SAAiB,EAAEtF,OAAsB,EAA6B;EACjG,IAAIyE,MAAiC;EACrC,IAAIc,aAAa,GAAGD,SAAS;;EAE7B;EACA,KAAK,MAAMlE,MAAM,IAAIpB,OAAO,EAAE;IAC5B,IAAI,CAACoB,MAAM,CAACW,KAAK,EAAE;MACjB;IACF;IAEA,MAAMe,KAAK,GAAGyC,aAAa,CAACzC,KAAK,CAAC1B,MAAM,CAACW,KAAK,CAAC;;IAE/C;IACA,IAAI,CAACe,KAAK,EAAE;MACV;IACF;;IAEA;IACA,MAAM0C,aAAa,GAAGpE,MAAM,CAACa,OAAO,EAChCW,KAAK,CAAC,GAAG,CAAC,CACXU,MAAM,CAAE8B,CAAC,IAAKA,CAAC,CAACtC,KAAK,CAAC,OAAO,CAAC,CAAC,CAC/BlB,MAAM,CAAsB,CAACC,GAAG,EAAEuD,CAAC,EAAE1C,CAAC,KAAK;MAC1C,IAAI0C,CAAC,CAACtC,KAAK,CAAC,KAAK,CAAC,EAAE;QAClB,OAAO;UACL,GAAGjB,GAAG;UACN,CAACuD,CAAC,GAAGtC,KAAK,CAAE,CAACJ,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC,CAAE;QAC5B,CAAC;MACH;MACA,OAAOhC,MAAM,CAACwC,MAAM,CAACrB,GAAG,EAAE;QACxB;QACA;QACA,CAACuD,CAAC,GAAGtC,KAAK,CAAE,CAACJ,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC,EAAE9C,OAAO,CAAC,IAAI,EAAE,EAAE;MAC5C,CAAC,CAAC;IACJ,CAAC,EAAE,CAAC,CAAC,CAAC;IAER,MAAM6F,aAAa,GAAIf,IAAY,IAAK;MACtC,MAAMtD,MAAM,GAAGpB,OAAO,CAACsE,IAAI,CAAEoB,CAAC,IAAKA,CAAC,CAACtC,MAAM,KAAKsB,IAAI,CAAC;MACrD,IAAI,CAACtD,MAAM,EAAEpC,IAAI,EAAE;QACjB,OAAO;UAAE0F;QAAK,CAAC;MACjB;MAEA,MAAMiB,QAAQ,GAAGvE,MAAM,CAACpC,IAAI,CAAC4D,KAAK,CAAC,GAAG,CAAC;MAEvC,MAAMgD,MAA2B,GAAG,CAAC,CAAC;MAEtCD,QAAQ,CACLrC,MAAM,CAAE8B,CAAC,IAAKA,CAAC,CAACtC,KAAK,CAAC,OAAO,CAAC,CAAC,CAC/B+C,OAAO,CAAET,CAAC,IAAK;QACd,IAAIhB,KAAK,GAAGoB,aAAa,CAACJ,CAAC,CAAC;QAC5B,IAAIhB,KAAK,EAAE;UACT,IAAIgB,CAAC,CAACtC,KAAK,CAAC,KAAK,CAAC,EAAE;YAClB;YACAsB,KAAK,GAAGA,KAAK,EAAExB,KAAK,CAAC,GAAG,CAAC,CAACU,MAAM,CAAC+B,OAAO,CAAC;UAC3C;UAEA,MAAMxE,GAAG,GAAGuE,CAAC,CAACxF,OAAO,CAAC,OAAO,EAAE,EAAE,CAAC,CAACA,OAAO,CAAC,KAAK,EAAE,EAAE,CAAC;UACrDgG,MAAM,CAAC/E,GAAG,CAAC,GAAGO,MAAM,CAAC0E,KAAK,GAAGjF,GAAG,CAAC,GAAGO,MAAM,CAAC0E,KAAK,CAACjF,GAAG,CAAC,CAACuD,KAAK,CAAC,GAAGA,KAAK;QACtE;MACF,CAAC,CAAC;MAEJ,IAAIwB,MAAM,IAAIlF,MAAM,CAACC,IAAI,CAACiF,MAAM,CAAC,CAACrD,MAAM,EAAE;QACxC,OAAO;UAAEmC,IAAI;UAAEkB;QAAO,CAAC;MACzB;MAEA,OAAO;QAAElB;MAAK,CAAC;IACjB,CAAC;IAEDD,MAAM,GAAGrD,MAAM,CAACG,UAAU,CAACX,GAAG,CAAE8D,IAAI,IAAK;MACvC,IAAI,CAACtD,MAAM,CAACuD,MAAM,EAAE;QAClB,OAAO;UAAE,GAAGc,aAAa,CAACf,IAAI;QAAE,CAAC;MACnC;MACA,OAAO;QACL,GAAGe,aAAa,CAACf,IAAI,CAAC;QACtBC,MAAM,EAAEvD,MAAM,CAACuD;MACjB,CAAC;IACH,CAAC,CAAC;;IAEF;IACA,MAAMoB,cAAc,GAAGtB,MAAM,CAAC7C,MAAM,CAClC,CAACC,GAAG,EAAEmE,CAAC,KAAKtF,MAAM,CAACwC,MAAM,CAACrB,GAAG,EAAEmE,CAAC,CAACJ,MAAM,CAAC,EACxC,CAAC,CACH,CAAC;IAED,MAAMK,iBAAiB,GAAGvF,MAAM,CAACC,IAAI,CAACoF,cAAc,CAAC,CAACxD,MAAM,GAAG,CAAC;;IAEhE;IACAkC,MAAM,GAAGA,MAAM,CAAC7D,GAAG,CAAEoF,CAAC,IAAK;MACzB,IAAIC,iBAAiB,EAAE;QACrBD,CAAC,CAACJ,MAAM,GAAGG,cAAc;MAC3B;MACA,OAAOC,CAAC;IACV,CAAC,CAAC;IAEFT,aAAa,GAAGA,aAAa,CAAC3F,OAAO,CAACkD,KAAK,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC;IAEnD;EACF;EAEA,OAAO2B,MAAM;AACf;AAEA,SAASyB,aAAaA,CAAC9D,CAAW,EAAEC,CAAW,EAAW;EACxD,IAAID,CAAC,CAACG,MAAM,KAAKF,CAAC,CAACE,MAAM,EAAE;IACzB,OAAO,KAAK;EACd;EACA,KAAK,IAAIG,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGN,CAAC,CAACG,MAAM,EAAEG,CAAC,EAAE,EAAE;IACjC,IAAIN,CAAC,CAACM,CAAC,CAAC,CAACS,aAAa,CAACd,CAAC,CAACK,CAAC,CAAC,CAAC,KAAK,CAAC,EAAE;MAClC,OAAO,KAAK;IACd;EACF;EACA,OAAO,IAAI;AACb;AAEA,MAAM5B,uBAAuB,GAAGA,CAC9BsC,MAAc,EACd+C,WAAkC,EAClC5E,UAAoB,GAAG,EAAE,EACzB6E,QAA8B,GAAG,EAAE,EACnC5F,aAAuB,GAAG,EAAE,EAC5B6F,aAAsB,KACJ;EAClB,MAAMrG,OAAsB,GAAG,EAAE;EAEjCuB,UAAU,CAAChB,IAAI,CAAC6C,MAAM,CAAC;EAEvB5C,aAAa,CAACD,IAAI,CAAC6C,MAAM,CAAC;EAE1B,MAAMhC,MAAM,GAAI+E,WAAW,CAAS/C,MAAM,CAAC;EAE3C,IAAI,OAAOhC,MAAM,KAAK,QAAQ,EAAE;IAC9B;;IAEA;IACA,MAAMa,OAAO,GAAGoE,aAAa,GAAGnF,SAAS,CAACmF,aAAa,EAAEjF,MAAM,CAAC,GAAGA,MAAM;IAEzEpB,OAAO,CAACO,IAAI,CAAC+F,gBAAgB,CAAClD,MAAM,EAAE7B,UAAU,EAAEU,OAAO,EAAEb,MAAM,EAAE,KAAK,CAAC,CAAC;EAC5E,CAAC,MAAM,IAAI,OAAOA,MAAM,KAAK,QAAQ,EAAE;IACrC,IAAIa,OAA2B;IAE/B,MAAM;MAAE0C;IAAO,CAAC,GAAGvD,MAAM;IACzB;IACA;IACA;IACA,IAAI,OAAOA,MAAM,CAACpC,IAAI,KAAK,QAAQ,EAAE;MACnC,IAAIoC,MAAM,CAACmF,KAAK,IAAInF,MAAM,CAACpC,IAAI,KAAKwF,SAAS,EAAE;QAC7C,MAAM,IAAInE,KAAK,CACb,sJACF,CAAC;MACH;MAEA4B,OAAO,GACLb,MAAM,CAACmF,KAAK,KAAK,IAAI,GACjBrF,SAAS,CAACmF,aAAa,IAAI,EAAE,EAAEjF,MAAM,CAACpC,IAAI,IAAI,EAAE,CAAC,GACjDoC,MAAM,CAACpC,IAAI,IAAI,EAAE;MAEvBgB,OAAO,CAACO,IAAI,CACV+F,gBAAgB,CACdlD,MAAM,EACN7B,UAAU,EACVU,OAAO,EACPb,MAAM,CAACpC,IAAI,EACXoC,MAAM,CAAChB,OAAO,GAAG,CAAC,CAACM,MAAM,CAACC,IAAI,CAACS,MAAM,CAAChB,OAAO,CAAC,EAAEmC,MAAM,GAAG,KAAK,EAC9DnB,MAAM,CAAC0E,KAAK,EACZnB,MACF,CACF,CAAC;IACH;IAEA,IAAIvD,MAAM,CAAChB,OAAO,EAAE;MAClB;MACA,IAAIgB,MAAM,CAACd,gBAAgB,EAAE;QAC3B8F,QAAQ,CAAC7F,IAAI,CAAC;UACZD,gBAAgB,EAAEc,MAAM,CAACd,gBAAgB;UACzCE;QACF,CAAC,CAAC;MACJ;MAEAE,MAAM,CAACC,IAAI,CAACS,MAAM,CAAChB,OAAO,CAAC,CAACyF,OAAO,CAAEW,YAAY,IAAK;QACpD,MAAMC,MAAM,GAAG3F,uBAAuB,CACpC0F,YAAY,EACZpF,MAAM,CAAChB,OAAO,EACdmB,UAAU,EACV6E,QAAQ,EACR,CAAC,GAAG5F,aAAa,CAAC,EAClByB,OAAO,IAAIoE,aACb,CAAC;QAEDrG,OAAO,CAACO,IAAI,CAAC,GAAGkG,MAAM,CAAC;MACzB,CAAC,CAAC;IACJ;EACF;EAEAlF,UAAU,CAACsB,GAAG,CAAC,CAAC;EAEhB,OAAO7C,OAAO;AAChB,CAAC;AAED,SAAS0G,kBAAkBA,CAACjE,EAAU,EAAU;EAC9C;EACAA,EAAE,GAAGA,EAAE,CAAC7C,OAAO,CAAC,GAAG,EAAE,KAAK,CAAC;EAE3B,IAAI6C,EAAE,CAACO,UAAU,CAAC,GAAG,CAAC,EAAE;IACtB;IACA,OAAQ,cAAaP,EAAE,CAACkE,QAAQ,CAAC,GAAG,CAAC,GAAG,GAAG,GAAG,EAAG,GAAE;EACrD,CAAC,MAAM,IAAIlE,EAAE,CAACO,UAAU,CAAC,GAAG,CAAC,EAAE;IAC7B,OAAQ,WAAUP,EAAE,CAACkE,QAAQ,CAAC,GAAG,CAAC,GAAG,GAAG,GAAG,EAAG,GAAE;EAClD;;EAEA;EACA,IAAI,IAAAnD,0BAAc,EAACf,EAAE,CAAC,IAAI,IAAI,EAAE;IAC9B;IACA;IACA;IACA,OAAQ,MAAK,IAAAmE,6BAAM,EAACnE,EAAE,CAAE,OAAM;EAChC;EAEA,OAAO,IAAAmE,6BAAM,EAACnE,EAAE,CAAC,GAAI,KAAI;AAC3B;AAEA,MAAM6D,gBAAgB,GAAGA,CACvBlD,MAAc,EACd7B,UAAoB,EACpBU,OAAe,EACfjD,IAAY,EACZmD,WAAqB,EACrB2D,KAAmB,EACnBnB,MAAY,KACI;EAChB;EACA1C,OAAO,GAAGA,OAAO,CAACW,KAAK,CAAC,GAAG,CAAC,CAACU,MAAM,CAAC+B,OAAO,CAAC,CAAC7D,IAAI,CAAC,GAAG,CAAC;EAEtD,MAAMO,KAAK,GAAGE,OAAO,GACjB,IAAI4E,MAAM,CAAE,KAAI5E,OAAO,CAACW,KAAK,CAAC,GAAG,CAAC,CAAChC,GAAG,CAAC8F,kBAAkB,CAAC,CAAClF,IAAI,CAAC,EAAE,CAAE,IAAG,CAAC,GACxEgD,SAAS;EAEb,OAAO;IACLpB,MAAM;IACNrB,KAAK;IACLE,OAAO;IACPjD,IAAI;IACJ;IACAuC,UAAU,EAAE,CAAC,GAAGA,UAAU,CAAC;IAC3BuE,KAAK;IACL7C,gBAAgB,EAAE,CAAC,GAAG1B,UAAU,CAACyD,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,EAAEhG,IAAI,IAAIoE,MAAM,CAAC,CAAC5B,IAAI,CAAC,GAAG,CAAC;IACxEW,WAAW,EAAE,CAAC,CAACA,WAAW;IAC1BwC;EACF,CAAC;AACH,CAAC;AAED,MAAMmC,uBAAuB,GAAGA,CAC9BC,SAAiB,EACjBC,YAA2B,KACC;EAC5B,KAAK,MAAM5F,MAAM,IAAI4F,YAAY,EAAE;IACjC,IAAID,SAAS,KAAK3F,MAAM,CAACG,UAAU,CAACH,MAAM,CAACG,UAAU,CAACgB,MAAM,GAAG,CAAC,CAAC,EAAE;MACjE,OAAOnB,MAAM,CAAC0E,KAAK;IACrB;EACF;EAEA,OAAOtB,SAAS;AAClB,CAAC;;AAED;AACA,MAAMyC,gBAAgB,GAAGA,CACvBF,SAAiB,EACjBvG,aAAuB,EACvBT,aAAmC,KACZ;EACvB,KAAK,MAAMqB,MAAM,IAAIrB,aAAa,EAAE;IAClC,IAAImG,aAAa,CAAC1F,aAAa,EAAEY,MAAM,CAACZ,aAAa,CAAC,EAAE;MACtD;MACA;MACA,OAAOuG,SAAS,KAAK3F,MAAM,CAACd,gBAAgB,GAAGc,MAAM,CAACd,gBAAgB,GAAGkE,SAAS;IACpF;EACF;EACA,OAAOA,SAAS;AAClB,CAAC;;AAED;AACA;AACA,MAAM0C,iBAAiB,GAAGA,CACxBjG,KAAkB,EAClBkG,OAAgB,EAChBC,YAAqB,KACJ;EACjB,IAAID,OAAO,EAAE;IACX,IAAIC,YAAY,EAAE;MAChB,OAAO;QACLC,KAAK,EAAE,CAAC;QACR5C,MAAM,EAAE,CAAC;UAAEC,IAAI,EAAE0C;QAAa,CAAC,EAAEnG,KAAK;MACxC,CAAC;IACH;IACA,OAAO;MACLwD,MAAM,EAAE,CAACxD,KAAK;IAChB,CAAC;EACH;EAEA,IAAImG,YAAY,EAAE;IAChB,OAAO;MACLC,KAAK,EAAE,CAAC;MACR5C,MAAM,EAAE,CAAC;QAAEC,IAAI,EAAE0C;MAAa,CAAC,EAAE;QAAE,GAAGnG,KAAK;QAAEqG,KAAK,EAAE;UAAE7C,MAAM,EAAE;QAAG;MAAE,CAAC;IACtE,CAAC;EACH;EACA,OAAO;IACLA,MAAM,EAAE,CAAC;MAAE,GAAGxD,KAAK;MAAEqG,KAAK,EAAE;QAAE7C,MAAM,EAAE;MAAG;IAAE,CAAC;EAC9C,CAAC;AACH,CAAC;AAED,MAAMG,uBAAuB,GAAGA,CAC9B5F,IAAY,EACZyF,MAAqB,EACrBuC,YAA2B,EAC3BjH,aAAmC,KAChC;EACH,IAAIkB,KAAK,GAAGwD,MAAM,CAAC8C,KAAK,CAAC,CAAgB;EACzC,MAAM/G,aAAuB,GAAG,EAAE;EAElC,IAAI4G,YAAY,GAAGH,gBAAgB,CAAChG,KAAK,CAACyD,IAAI,EAAElE,aAAa,EAAET,aAAa,CAAC;EAE7ES,aAAa,CAACD,IAAI,CAACU,KAAK,CAACyD,IAAI,CAAC;EAE9B,MAAM4C,KAAmB,GAAGJ,iBAAiB,CAACjG,KAAK,EAAEwD,MAAM,CAAClC,MAAM,KAAK,CAAC,EAAE6E,YAAY,CAAC;EAEvF,IAAI3C,MAAM,CAAClC,MAAM,GAAG,CAAC,EAAE;IACrB,IAAIiF,WAAW,GAAGF,KAAK;IAEvB,OAAQrG,KAAK,GAAGwD,MAAM,CAAC8C,KAAK,CAAC,CAAgB,EAAG;MAC9CH,YAAY,GAAGH,gBAAgB,CAAChG,KAAK,CAACyD,IAAI,EAAElE,aAAa,EAAET,aAAa,CAAC;MAEzE,MAAM0H,gBAAgB,GAAGD,WAAW,CAACH,KAAK,IAAIG,WAAW,CAAC/C,MAAM,CAAClC,MAAM,GAAG,CAAC;MAE3EiF,WAAW,CAAC/C,MAAM,CAACgD,gBAAgB,CAAC,CAACH,KAAK,GAAGJ,iBAAiB,CAC5DjG,KAAK,EACLwD,MAAM,CAAClC,MAAM,KAAK,CAAC,EACnB6E,YACF,CAAC;MAED,IAAI3C,MAAM,CAAClC,MAAM,GAAG,CAAC,EAAE;QACrBiF,WAAW,GAAGA,WAAW,CAAC/C,MAAM,CAACgD,gBAAgB,CAAC,CAACH,KAAqB;MAC1E;MAEA9G,aAAa,CAACD,IAAI,CAACU,KAAK,CAACyD,IAAI,CAAC;IAChC;EACF;EAEAzD,KAAK,GAAG,IAAAyG,oCAAgB,EAACJ,KAAK,CAAgB;;EAE9C;EACArG,KAAK,CAACjC,IAAI,GAAGA,IAAI;EAEjB,MAAM4G,MAAM,GAAG+B,gBAAgB,CAAC1G,KAAK,CAACjC,IAAI,EAAE8H,uBAAuB,CAAC7F,KAAK,CAACyD,IAAI,EAAEsC,YAAY,CAAC,CAAC;EAE9F,IAAIpB,MAAM,EAAE;IACV3E,KAAK,CAAC2E,MAAM,GAAGlF,MAAM,CAACwC,MAAM,CAACxC,MAAM,CAACkH,MAAM,CAAC,IAAI,CAAC,EAAE3G,KAAK,CAAC2E,MAAM,CAAwB;IACtF,KAAK,MAAM,CAAClB,IAAI,EAAEN,KAAK,CAAC,IAAI1D,MAAM,CAACmH,OAAO,CAACjC,MAAM,CAAC,EAAE;MAClD,IAAI3E,KAAK,CAAC2E,MAAM,GAAGlB,IAAI,CAAC,EAAE;QACxB,IAAIxF,OAAO,CAACC,GAAG,CAAC2I,QAAQ,KAAK,YAAY,EAAE;UACzCC,OAAO,CAACC,IAAI,CACT,WAAU/G,KAAK,CAACyD,IAAK,iBAAgBA,IAAK,qEAC7C,CAAC;QACH;MACF;MAEA,IAAI,CAACzD,KAAK,CAAC2E,MAAM,GAAGlB,IAAI,CAAC,EAAE;QACzBzD,KAAK,CAAC2E,MAAM,CAAClB,IAAI,CAAC,GAAGN,KAAK;QAC1B;MACF;IACF;IAEA,IAAI1D,MAAM,CAACC,IAAI,CAACM,KAAK,CAAC2E,MAAM,CAAC,CAACrD,MAAM,KAAK,CAAC,EAAE;MAC1C,OAAOtB,KAAK,CAAC2E,MAAM;IACrB;EACF;EAEA,OAAO0B,KAAK;AACd,CAAC;AAED,MAAMK,gBAAgB,GAAGA,CAAC3I,IAAY,EAAEiJ,WAAoD,KAAK;EAC/F,MAAMC,KAAK,GAAGlJ,IAAI,CAAC4D,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;EAChC,MAAMuF,YAAY,GAAG,IAAIC,eAAe,CAACF,KAAK,CAAC;EAC/C,MAAMtC,MAAM,GAAGlF,MAAM,CAAC2H,WAAW;EAC/B;EACAF,YACF,CAAC;EAED,IAAIF,WAAW,EAAE;IACfvH,MAAM,CAACC,IAAI,CAACiF,MAAM,CAAC,CAACC,OAAO,CAAEnB,IAAI,IAAK;MACpC,IAAIhE,MAAM,CAAC4H,cAAc,CAACC,IAAI,CAACN,WAAW,EAAEvD,IAAI,CAAC,IAAI,OAAOkB,MAAM,CAAClB,IAAI,CAAC,KAAK,QAAQ,EAAE;QACrFkB,MAAM,CAAClB,IAAI,CAAC,GAAGuD,WAAW,CAACvD,IAAI,CAAC,CAACkB,MAAM,CAAClB,IAAI,CAAW,CAAC;MAC1D;IACF,CAAC,CAAC;EACJ;EAEA,OAAOhE,MAAM,CAACC,IAAI,CAACiF,MAAM,CAAC,CAACrD,MAAM,GAAGqD,MAAM,GAAGpB,SAAS;AACxD,CAAC;AAED,MAAMgE,YAAY,GAAG,IAAIC,GAAG,CAAiB,CAAC;AAE9C,SAASC,eAAeA,CAACzJ,OAAe,EAAE;EACxC,IAAIuJ,YAAY,CAACG,GAAG,CAAC1J,OAAO,CAAC,EAAE;IAC7B,OAAOuJ,YAAY,CAACI,GAAG,CAAC3J,OAAO,CAAC;EAClC;EACA,MAAM8C,KAAK,GAAG,IAAI8E,MAAM,CAAE,QAAO,IAAAD,6BAAM,EAAC3H,OAAO,CAAE,EAAC,EAAE,GAAG,CAAC;EACxDuJ,YAAY,CAACK,GAAG,CAAC5J,OAAO,EAAE8C,KAAK,CAAC;EAChC,OAAOA,KAAK;AACd;AAEO,SAASpC,YAAYA,CAC1BX,IAAY,EACZC,OAA2B,GAAGC,OAAO,CAACC,GAAG,CAACC,aAAa,EACvD;EACA,IAAIF,OAAO,CAACC,GAAG,CAAC2I,QAAQ,KAAK,aAAa,EAAE;IAC1C,IAAI7I,OAAO,EAAE;MACX,MAAM6J,GAAG,GAAGJ,eAAe,CAACzJ,OAAO,CAAC;MACpC,OAAOD,IAAI,CAACY,OAAO,CAAC,OAAO,EAAE,GAAG,CAAC,CAACA,OAAO,CAACkJ,GAAG,EAAE,EAAE,CAAC;IACpD;EACF;EACA,OAAO9J,IAAI;AACb"}