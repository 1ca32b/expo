{"version":3,"file":"getRoutes.js","names":["_matchers","data","require","validPlatforms","Set","getRoutes","contextModule","options","directoryTree","getDirectoryTree","rootNode","flattenDirectoryTreeToRoutes","ignoreEntryPoints","crawlAndAppendInitialRoutesAndEntryFiles","getExactRoutes","skipGenerated","importMode","process","env","EXPO_ROUTER_IMPORT_MODE","ignoreList","ignore","push","preserveApiRoutes","rootDirectory","files","Map","subdirectories","hasRoutes","isValid","filePath","keys","some","regex","test","meta","getFileMeta","specificity","node","type","isApi","isLayout","loadRoute","ignoreRequireErrors","contextKey","route","dynamic","children","NODE_ENV","default","extrapolateGroups","subdirectoryParts","split","slice","directory","part","subDirectory","get","set","layout","existing","Error","getLayoutNode","fileKey","nodes","DefaultNavigator","generated","appendSitemapRoute","appendNotFoundRoute","pathToRemove","previousLayout","getMostSpecific","internal_stripLoadRoute","newRoute","replace","generateDynamic","routes","values","routeNode","child","key","parts","removeSupportedExtensions","filename","length","filenameWithoutExtensions","platformExtension","match","startsWith","endsWith","renamedRoute","join","hasPlatformExtension","has","usePlatformRoutes","platformRoutes","platform","RegExp","getIgnoreList","matchArrayGroupName","add","groups","groupsSet","size","group","trim","path","map","name","deep","notFound","deepDynamicName","matchDeepDynamicRouteName","dynamicName","matchDynamicName","filter","Sitemap","getNavOptions","internal","Unmatched","groupName","matchGroupName","childMatchingGroup","find","initialRouteName","loaded","unstable_settings","groupSpecificInitialRouteName","entryPoints","initialRoute","validInitialRoutes"],"sources":["../../src/getRoutes.ts"],"sourcesContent":["import type { DynamicConvention, RouteNode } from './Route';\nimport {\n  matchArrayGroupName,\n  matchDeepDynamicRouteName,\n  matchDynamicName,\n  matchGroupName,\n  removeSupportedExtensions,\n} from './matchers';\nimport type { RequireContext } from './types';\n\nexport type Options = {\n  ignore?: RegExp[];\n  preserveApiRoutes?: boolean;\n  ignoreRequireErrors?: boolean;\n  ignoreEntryPoints?: boolean;\n  /* Used to simplify testing for toEqual() comparison */\n  internal_stripLoadRoute?: boolean;\n  /* Used to simplify by skipping the generated routes */\n  skipGenerated?: boolean;\n  importMode?: string;\n  platformRoutes?: boolean;\n  platform?: string;\n};\n\ntype DirectoryNode = {\n  layout?: RouteNode[];\n  files: Map<string, RouteNode[]>;\n  subdirectories: Map<string, DirectoryNode>;\n};\n\nconst validPlatforms = new Set(['android', 'ios', 'native', 'web']);\n\n/**\n * Given a Metro context module, return an array of nested routes.\n *\n * This is a two step process:\n *  1. Convert the RequireContext keys (file paths) into a directory tree.\n *      - This should extrapolate array syntax into multiple routes\n *      - Routes are given a specificity score\n *  2. Flatten the directory tree into routes\n *      - Routes in directories without _layout files are hoisted to the nearest _layout\n *      - The name of the route is relative to the nearest _layout\n *      - If multiple routes have the same name, the most specific route is used\n */\nexport function getRoutes(contextModule: RequireContext, options: Options = {}): RouteNode | null {\n  const directoryTree = getDirectoryTree(contextModule, options);\n\n  // If there are no routes\n  if (!directoryTree) {\n    return null;\n  }\n\n  const rootNode = flattenDirectoryTreeToRoutes(directoryTree, options);\n\n  if (!options.ignoreEntryPoints) {\n    crawlAndAppendInitialRoutesAndEntryFiles(rootNode, options);\n  }\n\n  return rootNode;\n}\n\nexport function getExactRoutes(\n  contextModule: RequireContext,\n  options: Options = {}\n): RouteNode | null {\n  return getRoutes(contextModule, {\n    ...options,\n    skipGenerated: true,\n  });\n}\n\n/**\n * Converts the RequireContext keys (file paths) into a directory tree.\n */\nfunction getDirectoryTree(contextModule: RequireContext, options: Options) {\n  const importMode = options.importMode || process.env.EXPO_ROUTER_IMPORT_MODE;\n\n  const ignoreList: RegExp[] = [/^\\.\\/\\+(html|native-intent)\\.[tj]sx?$/]; // Ignore the top level ./+html file\n\n  if (options.ignore) {\n    ignoreList.push(...options.ignore);\n  }\n  if (!options.preserveApiRoutes) {\n    ignoreList.push(/\\+api\\.[tj]sx?$/);\n  }\n\n  const rootDirectory: DirectoryNode = {\n    files: new Map(),\n    subdirectories: new Map(),\n  };\n\n  let hasRoutes = false;\n  let isValid = false;\n\n  for (const filePath of contextModule.keys()) {\n    if (ignoreList.some((regex) => regex.test(filePath))) {\n      continue;\n    }\n\n    isValid = true;\n\n    const meta = getFileMeta(filePath, options);\n\n    // This is a file that should be ignored. e.g maybe it has an invalid platform?\n    if (meta.specificity < 0) {\n      continue;\n    }\n\n    let node: RouteNode = {\n      type: meta.isApi ? 'api' : meta.isLayout ? 'layout' : 'route',\n      loadRoute() {\n        if (options.ignoreRequireErrors) {\n          try {\n            return contextModule(filePath);\n          } catch {\n            return {};\n          }\n        } else {\n          return contextModule(filePath);\n        }\n      },\n      contextKey: filePath,\n      route: '', // This is overwritten during hoisting based upon the _layout\n      dynamic: null,\n      children: [], // While we are building the directory tree, we don't know the node's children just yet. This is added during hoisting\n    };\n\n    if (process.env.NODE_ENV === 'development') {\n      // If the user has set the `EXPO_ROUTER_IMPORT_MODE` to `sync` then we should\n      // filter the missing routes.\n      if (node.type !== 'api' && importMode === 'sync') {\n        if (!node.loadRoute()?.default) {\n          continue;\n        }\n      }\n    }\n\n    /**\n     * A single filepath may be extrapolated into multiple routes if it contains array syntax.\n     * Another way to thinking about is that a filepath node is present in multiple leaves of the directory tree.\n     */\n    for (const route of extrapolateGroups(meta.route)) {\n      // Traverse the directory tree to its leaf node, creating any missing directories along the way\n      const subdirectoryParts = route.split('/').slice(0, -1);\n\n      // Start at the root directory and traverse the path to the leaf directory\n      let directory = rootDirectory;\n\n      for (const part of subdirectoryParts) {\n        let subDirectory = directory.subdirectories.get(part);\n\n        // Create any missing subdirectories\n        if (!subDirectory) {\n          subDirectory = {\n            files: new Map(),\n            subdirectories: new Map(),\n          };\n          directory.subdirectories.set(part, subDirectory);\n        }\n\n        directory = subDirectory;\n      }\n\n      // Clone the node for this route\n      node = { ...node, route };\n\n      if (meta.isLayout) {\n        directory.layout ??= [];\n        const existing = directory.layout[meta.specificity];\n        if (existing) {\n          // In production, use the first route found\n          if (process.env.NODE_ENV !== 'production') {\n            throw new Error(\n              `The layouts \"${filePath}\" and \"${existing.contextKey}\" conflict on the route \"/${route}\". Please remove or rename one of these files.`\n            );\n          }\n        } else {\n          node = getLayoutNode(node, options);\n          directory.layout[meta.specificity] = node;\n        }\n      } else if (meta.isApi) {\n        const fileKey = `${route}+api`;\n        let nodes = directory.files.get(fileKey);\n\n        if (!nodes) {\n          nodes = [];\n          directory.files.set(fileKey, nodes);\n        }\n\n        // API Routes have no specificity, they are always the first node\n        const existing = nodes[0];\n\n        if (existing) {\n          // In production, use the first route found\n          if (process.env.NODE_ENV !== 'production') {\n            throw new Error(\n              `The API route file \"${filePath}\" and \"${existing.contextKey}\" conflict on the route \"/${route}\". Please remove or rename one of these files.`\n            );\n          }\n        } else {\n          nodes[0] = node;\n        }\n      } else {\n        let nodes = directory.files.get(route);\n\n        if (!nodes) {\n          nodes = [];\n          directory.files.set(route, nodes);\n        }\n\n        /**\n         * If there is an existing node with the same specificity, then we have a conflict.\n         * NOTE(Platform Routes):\n         *    We cannot check for specificity conflicts here, as we haven't processed all the context keys yet!\n         *    This will be checked during hoisting, as well as enforcing that all routes have a non-platform route.\n         */\n        const existing = nodes[meta.specificity];\n        if (existing) {\n          // In production, use the first route found\n          if (process.env.NODE_ENV !== 'production') {\n            throw new Error(\n              `The route files \"${filePath}\" and \"${existing.contextKey}\" conflict on the route \"/${route}\". Please remove or rename one of these files.`\n            );\n          }\n        } else {\n          hasRoutes ||= true;\n          nodes[meta.specificity] = node;\n        }\n      }\n    }\n  }\n\n  // If there are no routes/layouts then we should display the tutorial.\n  if (!isValid) {\n    return null;\n  }\n\n  /**\n   * If there are no top-level _layout, add a default _layout\n   * While this is a generated route, it will still be generated even if skipGenerated is true.\n   */\n  if (!rootDirectory.layout) {\n    rootDirectory.layout = [\n      {\n        type: 'layout',\n        loadRoute: () => ({\n          default: (require('./views/Navigator') as typeof import('./views/Navigator'))\n            .DefaultNavigator,\n        }),\n        // Generate a fake file name for the directory\n        contextKey: 'expo-router/build/views/Navigator.js',\n        route: '',\n        generated: true,\n        dynamic: null,\n        children: [],\n      },\n    ];\n  }\n\n  // Only include the sitemap if there are routes.\n  if (!options.skipGenerated) {\n    if (hasRoutes) {\n      appendSitemapRoute(rootDirectory);\n    }\n    appendNotFoundRoute(rootDirectory);\n  }\n  return rootDirectory;\n}\n\n/**\n * Flatten the directory tree into routes, hoisting routes to the nearest _layout.\n */\nfunction flattenDirectoryTreeToRoutes(\n  directory: DirectoryNode,\n  options: Options,\n  /* The nearest _layout file in the directory tree */\n  layout?: RouteNode,\n  /* Route names are relative to their layout */\n  pathToRemove = ''\n) {\n  /**\n   * This directory has a _layout file so it becomes the new target for hoisting routes.\n   */\n  if (directory.layout) {\n    const previousLayout = layout;\n    layout = getMostSpecific(directory.layout);\n\n    // Add the new layout as a child of its parent\n    if (previousLayout) {\n      previousLayout.children.push(layout);\n    }\n\n    if (options.internal_stripLoadRoute) {\n      delete (layout as any).loadRoute;\n    }\n\n    // `route` is the absolute pathname. We need to make this relative to the last _layout\n    const newRoute = layout.route.replace(pathToRemove, '');\n    pathToRemove = layout.route ? `${layout.route}/` : '';\n\n    // Now update this layout with the new relative route and dynamic conventions\n    layout.route = newRoute;\n    layout.dynamic = generateDynamic(layout.route);\n  }\n\n  // This should never occur as there will always be a root layout, but it makes the type system happy\n  if (!layout) throw new Error('Expo Router Internal Error: No nearest layout');\n\n  for (const routes of directory.files.values()) {\n    const routeNode = getMostSpecific(routes);\n\n    // `route` is the absolute pathname. We need to make this relative to the nearest layout\n    routeNode.route = routeNode.route.replace(pathToRemove, '');\n    routeNode.dynamic = generateDynamic(routeNode.route);\n\n    if (options.internal_stripLoadRoute) {\n      delete (routeNode as any).loadRoute;\n    }\n\n    layout.children.push(routeNode);\n  }\n\n  // Recursively flatten the subdirectories\n  for (const child of directory.subdirectories.values()) {\n    flattenDirectoryTreeToRoutes(child, options, layout, pathToRemove);\n  }\n\n  return layout;\n}\n\nfunction getFileMeta(key: string, options: Options) {\n  // Remove the leading `./`\n  key = key.replace(/^\\.\\//, '');\n\n  const parts = key.split('/');\n  let route = removeSupportedExtensions(key);\n  const filename = parts[parts.length - 1];\n  const [filenameWithoutExtensions, platformExtension] =\n    removeSupportedExtensions(filename).split('.');\n  const isLayout = filenameWithoutExtensions === '_layout';\n  const isApi = filename.match(/\\+api\\.(\\w+\\.)?[jt]sx?$/);\n\n  if (filenameWithoutExtensions.startsWith('(') && filenameWithoutExtensions.endsWith(')')) {\n    throw new Error(`Invalid route ./${key}. Routes cannot end with '(group)' syntax`);\n  }\n\n  // Nested routes cannot start with the '+' character, except for the '+not-found' route\n  if (!isApi && filename.startsWith('+') && filenameWithoutExtensions !== '+not-found') {\n    const renamedRoute = [...parts.slice(0, -1), filename.slice(1)].join('/');\n    throw new Error(\n      `Invalid route ./${key}. Route nodes cannot start with the '+' character. \"Please rename to ${renamedRoute}\"`\n    );\n  }\n  let specificity = 0;\n\n  const hasPlatformExtension = validPlatforms.has(platformExtension);\n  const usePlatformRoutes = options.platformRoutes ?? true;\n\n  if (hasPlatformExtension) {\n    if (!usePlatformRoutes) {\n      // If the user has disabled platform routes, then we should ignore this file\n      specificity = -1;\n    } else if (!options.platform) {\n      // If we don't have a platform, then we should ignore this file\n      // This used by typed routes, sitemap, etc\n      specificity = -1;\n    } else if (platformExtension === options.platform) {\n      // If the platform extension is the same as the options.platform, then it is the most specific\n      specificity = 2;\n    } else if (platformExtension === 'native' && options.platform !== 'web') {\n      // `native` is allow but isn't as specific as the platform\n      specificity = 1;\n    } else if (platformExtension !== options.platform) {\n      // Somehow we have a platform extension that doesn't match the options.platform and it isn't native\n      // This is an invalid file and we will ignore it\n      specificity = -1;\n    }\n\n    if (isApi && specificity !== 0) {\n      throw new Error(\n        `Api routes cannot have platform extensions. Please remove '.${platformExtension}' from './${key}'`\n      );\n    }\n\n    route = route.replace(new RegExp(`.${platformExtension}$`), '');\n  }\n\n  return {\n    route,\n    specificity,\n    isLayout,\n    isApi,\n  };\n}\n\nexport function getIgnoreList(options?: Options) {\n  const ignore: RegExp[] = [/^\\.\\/\\+html\\.[tj]sx?$/, ...(options?.ignore ?? [])];\n  if (options?.preserveApiRoutes !== true) {\n    ignore.push(/\\+api\\.[tj]sx?$/);\n  }\n  return ignore;\n}\n\n/**\n * Generates a set of strings which have the router array syntax extrapolated.\n *\n * /(a,b)/(c,d)/e.tsx => new Set(['a/c/e.tsx', 'a/d/e.tsx', 'b/c/e.tsx', 'b/d/e.tsx'])\n */\nexport function extrapolateGroups(key: string, keys: Set<string> = new Set()): Set<string> {\n  const match = matchArrayGroupName(key);\n\n  if (!match) {\n    keys.add(key);\n    return keys;\n  }\n  const groups = match.split(',');\n  const groupsSet = new Set(groups);\n\n  if (groupsSet.size !== groups.length) {\n    throw new Error(`Array syntax cannot contain duplicate group name \"${groups}\" in \"${key}\".`);\n  }\n\n  if (groups.length === 1) {\n    keys.add(key);\n    return keys;\n  }\n\n  for (const group of groups) {\n    extrapolateGroups(key.replace(match, group.trim()), keys);\n  }\n\n  return keys;\n}\n\nexport function generateDynamic(path: string): DynamicConvention[] | null {\n  const dynamic = path\n    .split('/')\n    .map((part): DynamicConvention | null => {\n      if (part === '+not-found') {\n        return {\n          name: '+not-found',\n          deep: true,\n          notFound: true,\n        };\n      }\n\n      const deepDynamicName = matchDeepDynamicRouteName(part);\n      const dynamicName = deepDynamicName ?? matchDynamicName(part);\n\n      if (!dynamicName) return null;\n      return { name: dynamicName, deep: !!deepDynamicName };\n    })\n    .filter((part): part is DynamicConvention => !!part);\n\n  return dynamic.length === 0 ? null : dynamic;\n}\n\nfunction appendSitemapRoute(directory: DirectoryNode) {\n  if (!directory.files.has('_sitemap')) {\n    directory.files.set('_sitemap', [\n      {\n        loadRoute() {\n          const { Sitemap, getNavOptions } = require('./views/Sitemap');\n          return { default: Sitemap, getNavOptions };\n        },\n        route: '_sitemap',\n        type: 'route',\n        contextKey: 'expo-router/build/views/Sitemap.js',\n        generated: true,\n        internal: true,\n        dynamic: null,\n        children: [],\n      },\n    ]);\n  }\n}\n\nfunction appendNotFoundRoute(directory: DirectoryNode) {\n  if (!directory.files.has('+not-found')) {\n    directory.files.set('+not-found', [\n      {\n        loadRoute() {\n          return { default: require('./views/Unmatched').Unmatched };\n        },\n        type: 'route',\n        route: '+not-found',\n        contextKey: 'expo-router/build/views/Unmatched.js',\n        generated: true,\n        internal: true,\n        dynamic: [{ name: '+not-found', deep: true, notFound: true }],\n        children: [],\n      },\n    ]);\n  }\n}\n\nfunction getLayoutNode(node: RouteNode, options: Options) {\n  /**\n   * A file called `(a,b)/(c)/_layout.tsx` will generate two _layout routes: `(a)/(c)/_layout` and `(b)/(c)/_layout`.\n   * Each of these layouts will have a different initialRouteName based upon the first group name.\n   *\n   * So\n   */\n\n  // We may strip loadRoute during testing\n  const groupName = matchGroupName(node.route);\n  const childMatchingGroup = node.children.find((child) => {\n    return child.route.replace(/\\/index$/, '') === groupName;\n  });\n  let initialRouteName = childMatchingGroup?.route;\n  const loaded = node.loadRoute();\n  if (loaded?.unstable_settings) {\n    // Allow unstable_settings={ initialRouteName: '...' } to override the default initial route name.\n    initialRouteName = loaded.unstable_settings.initialRouteName ?? initialRouteName;\n\n    if (groupName) {\n      // Allow unstable_settings={ 'custom': { initialRouteName: '...' } } to override the less specific initial route name.\n      const groupSpecificInitialRouteName = loaded.unstable_settings?.[groupName]?.initialRouteName;\n\n      initialRouteName = groupSpecificInitialRouteName ?? initialRouteName;\n    }\n  }\n\n  return {\n    ...node,\n    route: node.route.replace(/\\/?_layout$/, ''),\n    children: [], // Each layout should have its own children\n    initialRouteName,\n  };\n}\n\nfunction crawlAndAppendInitialRoutesAndEntryFiles(\n  node: RouteNode,\n  options: Options,\n  entryPoints: string[] = []\n) {\n  if (node.type === 'route') {\n    node.entryPoints = [...new Set([...entryPoints, node.contextKey])];\n  } else if (node.type === 'layout') {\n    if (!node.children) {\n      throw new Error(`Layout \"${node.contextKey}\" does not contain any child routes`);\n    }\n\n    // Every node below this layout will have it as an entryPoint\n    entryPoints = [...entryPoints, node.contextKey];\n\n    /**\n     * Calculate the initialRouteNode\n     *\n     * A file called `(a,b)/(c)/_layout.tsx` will generate two _layout routes: `(a)/(c)/_layout` and `(b)/(c)/_layout`.\n     * Each of these layouts will have a different initialRouteName based upon the first group.\n     */\n    const groupName = matchGroupName(node.route);\n    const childMatchingGroup = node.children.find((child) => {\n      return child.route.replace(/\\/index$/, '') === groupName;\n    });\n    let initialRouteName = childMatchingGroup?.route;\n    // We may strip loadRoute during testing\n    if (!options.internal_stripLoadRoute) {\n      const loaded = node.loadRoute();\n      if (loaded?.unstable_settings) {\n        // Allow unstable_settings={ initialRouteName: '...' } to override the default initial route name.\n        initialRouteName = loaded.unstable_settings.initialRouteName ?? initialRouteName;\n\n        if (groupName) {\n          // Allow unstable_settings={ 'custom': { initialRouteName: '...' } } to override the less specific initial route name.\n          const groupSpecificInitialRouteName =\n            loaded.unstable_settings?.[groupName]?.initialRouteName;\n\n          initialRouteName = groupSpecificInitialRouteName ?? initialRouteName;\n        }\n      }\n    }\n\n    if (initialRouteName) {\n      const initialRoute = node.children.find((child) => child.route === initialRouteName);\n      if (!initialRoute) {\n        const validInitialRoutes = node.children\n          .filter((child) => !child.generated)\n          .map((child) => `'${child.route}'`)\n          .join(', ');\n\n        if (groupName) {\n          throw new Error(\n            `Layout ${node.contextKey} has invalid initialRouteName '${initialRouteName}' for group '(${groupName})'. Valid options are: ${validInitialRoutes}`\n          );\n        } else {\n          throw new Error(\n            `Layout ${node.contextKey} has invalid initialRouteName '${initialRouteName}'. Valid options are: ${validInitialRoutes}`\n          );\n        }\n      }\n\n      // Navigators can add initialsRoutes into the history, so they need to be to be included in the entryPoints\n      node.initialRouteName = initialRouteName;\n      entryPoints.push(initialRoute.contextKey);\n    }\n\n    for (const child of node.children) {\n      crawlAndAppendInitialRoutesAndEntryFiles(child, options, entryPoints);\n    }\n  }\n}\n\nfunction getMostSpecific(routes: RouteNode[]) {\n  const route = routes[routes.length - 1];\n\n  if (!routes[0]) {\n    throw new Error(\n      `The file ${route.contextKey} does not have a fallback sibling file without a platform extension.`\n    );\n  }\n\n  // This works even tho routes is holey array (e.g it might have index 0 and 2 but not 1)\n  // `.length` includes the holes in its count\n  return routes[routes.length - 1];\n}\n"],"mappings":"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"}