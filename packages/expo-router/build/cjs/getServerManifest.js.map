{"version":3,"file":"getServerManifest.js","names":["_matchers","data","require","_sortRoutes","isNotFoundRoute","route","dynamic","length","notFound","uniqueBy","arr","key","seen","Set","filter","item","id","has","add","getServerManifest","getFlatNodes","children","map","child","flat","type","getContextKey","contextKey","replace","sort","a","b","sortRoutes","reverse","apiRoutes","path","otherRoutes","standardRoutes","notFoundRoutes","getMatchableManifestForPaths","normalizedRoutePath","node","htmlRoutes","paths","matcher","getNamedRouteRegex","generated","normalizedRoute","page","file","result","getNamedParametrizedRoute","namedRegex","namedParameterizedRoute","routeKeys","buildGetSafeRouteKey","currentCharCode","currentLength","incrementNext","i","String","fromCharCode","removeTrailingSlash","segments","slice","split","getSafeRouteKey","segment","index","test","name","optional","repeat","parseParameter","cleanedKey","invalidKey","isNaN","parseInt","groupName","matchGroupName","group","trim","Boolean","optionalSegment","escapeStringRegexp","join","reHasRegExp","reReplaceRegExp","str","param"],"sources":["../../src/getServerManifest.ts"],"sourcesContent":["/**\n * Copyright © 2023 650 Industries.\n * Copyright © 2023 Vercel, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * Based on https://github.com/vercel/next.js/blob/1df2686bc9964f1a86c444701fa5cbf178669833/packages/next/src/shared/lib/router/utils/route-regex.ts\n */\nimport type { RouteNode } from './Route';\nimport { getContextKey, matchGroupName } from './matchers';\nimport { sortRoutes } from './sortRoutes';\n\n// TODO: Share these types across cli, server, router, etc.\nexport type ExpoRouterServerManifestV1Route<TRegex = string> = {\n  file: string;\n  page: string;\n  routeKeys: Record<string, string>;\n  namedRegex: TRegex;\n  generated?: boolean;\n};\n\nexport type ExpoRouterServerManifestV1<TRegex = string> = {\n  apiRoutes: ExpoRouterServerManifestV1Route<TRegex>[];\n  htmlRoutes: ExpoRouterServerManifestV1Route<TRegex>[];\n  notFoundRoutes: ExpoRouterServerManifestV1Route<TRegex>[];\n};\n\nexport interface Group {\n  pos: number;\n  repeat: boolean;\n  optional: boolean;\n}\n\nexport interface RouteRegex {\n  groups: Record<string, Group>;\n  re: RegExp;\n}\n\nfunction isNotFoundRoute(route: RouteNode) {\n  return route.dynamic && route.dynamic[route.dynamic.length - 1].notFound;\n}\n\nfunction uniqueBy<T>(arr: T[], key: (item: T) => string): T[] {\n  const seen = new Set<string>();\n  return arr.filter((item) => {\n    const id = key(item);\n    if (seen.has(id)) {\n      return false;\n    }\n    seen.add(id);\n    return true;\n  });\n}\n\n// Given a nested route tree, return a flattened array of all routes that can be matched.\nexport function getServerManifest(route: RouteNode): ExpoRouterServerManifestV1 {\n  function getFlatNodes(route: RouteNode): [string, RouteNode][] {\n    if (route.children.length) {\n      return route.children.map((child) => getFlatNodes(child)).flat();\n    }\n\n    // API Routes are handled differently to HTML routes because they have no nested behavior.\n    // An HTML route can be different based on parent segments due to layout routes, therefore multiple\n    // copies should be rendered. However, an API route is always the same regardless of parent segments.\n    let key: string;\n    if (route.type === 'api') {\n      key = getContextKey(route.contextKey).replace(/\\/index$/, '') ?? '/';\n    } else {\n      key = getContextKey(route.route).replace(/\\/index$/, '') ?? '/';\n    }\n    return [[key, route]];\n  }\n\n  // Remove duplicates from the runtime manifest which expands array syntax.\n  const flat = getFlatNodes(route)\n    .sort(([, a], [, b]) => sortRoutes(b, a))\n    .reverse();\n\n  const apiRoutes = uniqueBy(\n    flat.filter(([, route]) => route.type === 'api'),\n    ([path]) => path\n  );\n  const otherRoutes = uniqueBy(\n    flat.filter(([, route]) => route.type === 'route'),\n    ([path]) => path\n  );\n  const standardRoutes = otherRoutes.filter(([, route]) => !isNotFoundRoute(route));\n  const notFoundRoutes = otherRoutes.filter(([, route]) => isNotFoundRoute(route));\n\n  return {\n    apiRoutes: getMatchableManifestForPaths(\n      apiRoutes.map(([normalizedRoutePath, node]) => [normalizedRoutePath, node])\n    ),\n    htmlRoutes: getMatchableManifestForPaths(\n      standardRoutes.map(([normalizedRoutePath, node]) => [normalizedRoutePath, node])\n    ),\n    notFoundRoutes: getMatchableManifestForPaths(\n      notFoundRoutes.map(([normalizedRoutePath, node]) => [normalizedRoutePath, node])\n    ),\n  };\n}\n\nfunction getMatchableManifestForPaths(\n  paths: [string, RouteNode][]\n): ExpoRouterServerManifestV1Route[] {\n  return paths.map((normalizedRoutePath) => {\n    const matcher: ExpoRouterServerManifestV1Route = getNamedRouteRegex(\n      normalizedRoutePath[0],\n      getContextKey(normalizedRoutePath[1].route),\n      normalizedRoutePath[1].contextKey\n    );\n    if (normalizedRoutePath[1].generated) {\n      matcher.generated = true;\n    }\n    return matcher;\n  });\n}\n\nfunction getNamedRouteRegex(\n  normalizedRoute: string,\n  page: string,\n  file: string\n): ExpoRouterServerManifestV1Route {\n  const result = getNamedParametrizedRoute(normalizedRoute);\n  return {\n    file,\n    page,\n    namedRegex: `^${result.namedParameterizedRoute}(?:/)?$`,\n    routeKeys: result.routeKeys,\n  };\n}\n\n/**\n * Builds a function to generate a minimal routeKey using only a-z and minimal\n * number of characters.\n */\nfunction buildGetSafeRouteKey() {\n  let currentCharCode = 96; // Starting one before 'a' to make the increment logic simpler\n  let currentLength = 1;\n\n  return () => {\n    let result = '';\n    let incrementNext = true;\n\n    // Iterate from right to left to build the key\n    for (let i = 0; i < currentLength; i++) {\n      if (incrementNext) {\n        currentCharCode++;\n        if (currentCharCode > 122) {\n          currentCharCode = 97; // Reset to 'a'\n          incrementNext = true; // Continue to increment the next character\n        } else {\n          incrementNext = false;\n        }\n      }\n      result = String.fromCharCode(currentCharCode) + result;\n    }\n\n    // If all characters are 'z', increase the length of the key\n    if (incrementNext) {\n      currentLength++;\n      currentCharCode = 96; // This will make the next key start with 'a'\n    }\n\n    return result;\n  };\n}\n\nfunction removeTrailingSlash(route: string): string {\n  return route.replace(/\\/$/, '') || '/';\n}\n\nfunction getNamedParametrizedRoute(route: string) {\n  const segments = removeTrailingSlash(route).slice(1).split('/');\n  const getSafeRouteKey = buildGetSafeRouteKey();\n  const routeKeys: Record<string, string> = {};\n  return {\n    namedParameterizedRoute: segments\n      .map((segment, index) => {\n        if (segment === '+not-found' && index === segments.length - 1) {\n          segment = '[...not-found]';\n        }\n        if (/^\\[.*\\]$/.test(segment)) {\n          const { name, optional, repeat } = parseParameter(segment);\n          // replace any non-word characters since they can break\n          // the named regex\n          let cleanedKey = name.replace(/\\W/g, '');\n          let invalidKey = false;\n\n          // check if the key is still invalid and fallback to using a known\n          // safe key\n          if (cleanedKey.length === 0 || cleanedKey.length > 30) {\n            invalidKey = true;\n          }\n          if (!isNaN(parseInt(cleanedKey.slice(0, 1), 10))) {\n            invalidKey = true;\n          }\n\n          // Prevent duplicates after sanitizing the key\n          if (cleanedKey in routeKeys) {\n            invalidKey = true;\n          }\n\n          if (invalidKey) {\n            cleanedKey = getSafeRouteKey();\n          }\n\n          routeKeys[cleanedKey] = name;\n          return repeat\n            ? optional\n              ? `(?:/(?<${cleanedKey}>.+?))?`\n              : `/(?<${cleanedKey}>.+?)`\n            : `/(?<${cleanedKey}>[^/]+?)`;\n        } else if (/^\\(.*\\)$/.test(segment)) {\n          const groupName = matchGroupName(segment)!\n            .split(',')\n            .map((group) => group.trim())\n            .filter(Boolean);\n          if (groupName.length > 1) {\n            const optionalSegment = `\\\\((?:${groupName.map(escapeStringRegexp).join('|')})\\\\)`;\n            // Make section optional\n            return `(?:/${optionalSegment})?`;\n          } else {\n            // Use simpler regex for single groups\n            return `(?:/${escapeStringRegexp(segment)})?`;\n          }\n        } else {\n          return `/${escapeStringRegexp(segment)}`;\n        }\n      })\n      .join(''),\n    routeKeys,\n  };\n}\n\n// regexp is based on https://github.com/sindresorhus/escape-string-regexp\nconst reHasRegExp = /[|\\\\{}()[\\]^$+*?.-]/;\nconst reReplaceRegExp = /[|\\\\{}()[\\]^$+*?.-]/g;\n\nfunction escapeStringRegexp(str: string) {\n  // see also: https://github.com/lodash/lodash/blob/2da024c3b4f9947a48517639de7560457cd4ec6c/escapeRegExp.js#L23\n  if (reHasRegExp.test(str)) {\n    return str.replace(reReplaceRegExp, '\\\\$&');\n  }\n  return str;\n}\n\nexport function parseParameter(param: string) {\n  let repeat = false;\n  let optional = false;\n  let name = param;\n\n  if (/^\\[.*\\]$/.test(name)) {\n    optional = true;\n    name = name.slice(1, -1);\n  }\n\n  if (/^\\.\\.\\./.test(name)) {\n    repeat = true;\n    name = name.slice(3);\n  }\n\n  return { name, repeat, optional };\n}\n"],"mappings":"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"}