{"version":3,"file":"getReactNavigationConfig.js","names":["_matchers","data","require","convertDynamicRouteToReactNavigation","segment","rest","matchDeepDynamicRouteName","dynamicName","matchDynamicName","parseRouteSegments","segments","split","map","filter","Boolean","join","convertRouteNodeToScreen","node","metaOnly","path","route","children","length","screens","_route","getReactNavigationScreensConfig","screen","initialRouteName","nodes","Object","fromEntries","getReactNavigationConfig","routes"],"sources":["../../src/getReactNavigationConfig.ts"],"sourcesContent":["import type { RouteNode } from './Route';\nimport { matchDeepDynamicRouteName, matchDynamicName } from './matchers';\n\nexport type Screen =\n  | string\n  | {\n      path: string;\n      screens: Record<string, Screen>;\n      _route?: RouteNode;\n      initialRouteName?: string;\n    };\n\n// `[page]` -> `:page`\n// `page` -> `page`\nfunction convertDynamicRouteToReactNavigation(segment: string): string {\n  // NOTE(EvanBacon): To support shared routes we preserve group segments.\n  if (segment === 'index') {\n    return '';\n  }\n  if (segment === '+not-found') {\n    return '*not-found';\n  }\n\n  const rest = matchDeepDynamicRouteName(segment);\n  if (rest != null) {\n    return '*' + rest;\n  }\n  const dynamicName = matchDynamicName(segment);\n\n  if (dynamicName != null) {\n    return `:${dynamicName}`;\n  }\n\n  return segment;\n}\n\nfunction parseRouteSegments(segments: string): string {\n  return (\n    // NOTE(EvanBacon): When there are nested routes without layouts\n    // the node.route will be something like `app/home/index`\n    // this needs to be split to ensure each segment is parsed correctly.\n    segments\n      .split('/')\n      // Convert each segment to a React Navigation format.\n      .map(convertDynamicRouteToReactNavigation)\n      // Remove any empty paths from groups or index routes.\n      .filter(Boolean)\n      // Join to return as a path.\n      .join('/')\n  );\n}\n\nfunction convertRouteNodeToScreen(node: RouteNode, metaOnly: boolean): Screen {\n  const path = parseRouteSegments(node.route);\n  if (!node.children.length) {\n    if (!metaOnly) {\n      return {\n        path,\n        screens: {},\n        _route: node,\n      };\n    }\n    return path;\n  }\n  const screens = getReactNavigationScreensConfig(node.children, metaOnly);\n\n  const screen: Screen = {\n    path,\n    screens,\n    // NOTE(EvanBacon): This is bad because it forces all Layout Routes\n    // to be loaded into memory. We should move towards a system where\n    // the initial route name is either loaded asynchronously in the Layout Route\n    // or defined via a file system convention.\n    initialRouteName: node.initialRouteName,\n  };\n\n  if (!metaOnly) {\n    screen._route = node;\n  }\n\n  return screen;\n}\n\nexport function getReactNavigationScreensConfig(\n  nodes: RouteNode[],\n  metaOnly: boolean\n): Record<string, Screen> {\n  return Object.fromEntries(\n    nodes.map((node) => [node.route, convertRouteNodeToScreen(node, metaOnly)] as const)\n  );\n}\n\nexport function getReactNavigationConfig(\n  routes: RouteNode,\n  metaOnly: boolean\n): {\n  initialRouteName?: string;\n  screens: Record<string, Screen>;\n} {\n  return {\n    initialRouteName: routes.initialRouteName,\n    screens: getReactNavigationScreensConfig(routes.children, metaOnly),\n  };\n}\n"],"mappings":";;;;;;;AACA,SAAAA,UAAA;EAAA,MAAAC,IAAA,GAAAC,OAAA;EAAAF,SAAA,YAAAA,CAAA;IAAA,OAAAC,IAAA;EAAA;EAAA,OAAAA,IAAA;AAAA;AAWA;AACA;AACA,SAASE,oCAAoCA,CAACC,OAAe,EAAU;EACrE;EACA,IAAIA,OAAO,KAAK,OAAO,EAAE;IACvB,OAAO,EAAE;EACX;EACA,IAAIA,OAAO,KAAK,YAAY,EAAE;IAC5B,OAAO,YAAY;EACrB;EAEA,MAAMC,IAAI,GAAG,IAAAC,qCAAyB,EAACF,OAAO,CAAC;EAC/C,IAAIC,IAAI,IAAI,IAAI,EAAE;IAChB,OAAO,GAAG,GAAGA,IAAI;EACnB;EACA,MAAME,WAAW,GAAG,IAAAC,4BAAgB,EAACJ,OAAO,CAAC;EAE7C,IAAIG,WAAW,IAAI,IAAI,EAAE;IACvB,OAAQ,IAAGA,WAAY,EAAC;EAC1B;EAEA,OAAOH,OAAO;AAChB;AAEA,SAASK,kBAAkBA,CAACC,QAAgB,EAAU;EACpD;IACE;IACA;IACA;IACAA,QAAQ,CACLC,KAAK,CAAC,GAAG;IACV;IAAA,CACCC,GAAG,CAACT,oCAAoC;IACzC;IAAA,CACCU,MAAM,CAACC,OAAO;IACf;IAAA,CACCC,IAAI,CAAC,GAAG;EAAC;AAEhB;AAEA,SAASC,wBAAwBA,CAACC,IAAe,EAAEC,QAAiB,EAAU;EAC5E,MAAMC,IAAI,GAAGV,kBAAkB,CAACQ,IAAI,CAACG,KAAK,CAAC;EAC3C,IAAI,CAACH,IAAI,CAACI,QAAQ,CAACC,MAAM,EAAE;IACzB,IAAI,CAACJ,QAAQ,EAAE;MACb,OAAO;QACLC,IAAI;QACJI,OAAO,EAAE,CAAC,CAAC;QACXC,MAAM,EAAEP;MACV,CAAC;IACH;IACA,OAAOE,IAAI;EACb;EACA,MAAMI,OAAO,GAAGE,+BAA+B,CAACR,IAAI,CAACI,QAAQ,EAAEH,QAAQ,CAAC;EAExE,MAAMQ,MAAc,GAAG;IACrBP,IAAI;IACJI,OAAO;IACP;IACA;IACA;IACA;IACAI,gBAAgB,EAAEV,IAAI,CAACU;EACzB,CAAC;EAED,IAAI,CAACT,QAAQ,EAAE;IACbQ,MAAM,CAACF,MAAM,GAAGP,IAAI;EACtB;EAEA,OAAOS,MAAM;AACf;AAEO,SAASD,+BAA+BA,CAC7CG,KAAkB,EAClBV,QAAiB,EACO;EACxB,OAAOW,MAAM,CAACC,WAAW,CACvBF,KAAK,CAAChB,GAAG,CAAEK,IAAI,IAAK,CAACA,IAAI,CAACG,KAAK,EAAEJ,wBAAwB,CAACC,IAAI,EAAEC,QAAQ,CAAC,CAAU,CACrF,CAAC;AACH;AAEO,SAASa,wBAAwBA,CACtCC,MAAiB,EACjBd,QAAiB,EAIjB;EACA,OAAO;IACLS,gBAAgB,EAAEK,MAAM,CAACL,gBAAgB;IACzCJ,OAAO,EAAEE,+BAA+B,CAACO,MAAM,CAACX,QAAQ,EAAEH,QAAQ;EACpE,CAAC;AACH"}