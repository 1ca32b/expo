{"version":3,"file":"Route.js","sourceRoot":"","sources":["../src/Route.tsx"],"names":[],"mappings":"AAAA,YAAY,CAAC;AAEb,OAAO,KAAK,EAAE,EAA0B,UAAU,EAAE,MAAM,OAAO,CAAC;AAGlE,OAAO,EAAE,aAAa,EAAE,MAAM,YAAY,CAAC;AAC3C,OAAO,EAAE,qBAAqB,EAAE,UAAU,EAAE,MAAM,cAAc,CAAC;AAqCjE,MAAM,mBAAmB,GAAG,KAAK,CAAC,aAAa,CAAmB,IAAI,CAAC,CAAC;AAExE,IAAI,OAAO,CAAC,GAAG,CAAC,QAAQ,KAAK,YAAY,EAAE;IACzC,mBAAmB,CAAC,WAAW,GAAG,WAAW,CAAC;CAC/C;AAED,+DAA+D;AAC/D,MAAM,UAAU,YAAY;IAC1B,OAAO,UAAU,CAAC,mBAAmB,CAAC,CAAC;AACzC,CAAC;AAED,MAAM,UAAU,aAAa;IAC3B,MAAM,IAAI,GAAG,YAAY,EAAE,CAAC;IAC5B,IAAI,IAAI,IAAI,IAAI,EAAE;QAChB,MAAM,IAAI,KAAK,CAAC,yDAAyD,CAAC,CAAC;KAC5E;IACD,OAAO,aAAa,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;AACxC,CAAC;AAED,iEAAiE;AACjE,MAAM,UAAU,KAAK,CAAC,EAAE,QAAQ,EAAE,IAAI,EAA0C;IAC9E,OAAO,CAAC,mBAAmB,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,QAAQ,CAAC,EAAE,mBAAmB,CAAC,QAAQ,CAAC,CAAC;AAC9F,CAAC;AAED,OAAO,EAAE,qBAAqB,EAAE,UAAU,EAAE,CAAC","sourcesContent":["'use client';\n\nimport React, { type PropsWithChildren, useContext } from 'react';\n\nimport type { ErrorBoundaryProps } from './exports';\nimport { getContextKey } from './matchers';\nimport { sortRoutesWithInitial, sortRoutes } from './sortRoutes';\n\nexport type DynamicConvention = { name: string; deep: boolean; notFound?: boolean };\n\nexport type LoadedRoute = {\n  ErrorBoundary?: React.ComponentType<ErrorBoundaryProps>;\n  default?: React.ComponentType<any>;\n  unstable_settings?: Record<string, any>;\n  getNavOptions?: (args: any) => any;\n  generateStaticParams?: (props: {\n    params?: Record<string, string | string[]>;\n  }) => Record<string, string | string[]>[];\n};\n\nexport type RouteNode = {\n  /** The type of RouteNode */\n  type: 'route' | 'api' | 'layout';\n  /** Load a route into memory. Returns the exports from a route. */\n  loadRoute: () => Partial<LoadedRoute>;\n  /** Loaded initial route name. */\n  initialRouteName?: string;\n  /** nested routes */\n  children: RouteNode[];\n  /** Is the route a dynamic path */\n  dynamic: null | DynamicConvention[];\n  /** `index`, `error-boundary`, etc. */\n  route: string;\n  /** Context Module ID, used for matching children. */\n  contextKey: string;\n  /** Added in-memory */\n  generated?: boolean;\n  /** Internal screens like the directory or the auto 404 should be marked as internal. */\n  internal?: boolean;\n  /** File paths for async entry modules that should be included in the initial chunk request to ensure the runtime JavaScript matches the statically rendered HTML representation. */\n  entryPoints?: string[];\n};\n\nconst CurrentRouteContext = React.createContext<RouteNode | null>(null);\n\nif (process.env.NODE_ENV !== 'production') {\n  CurrentRouteContext.displayName = 'RouteNode';\n}\n\n/** Return the RouteNode at the current contextual boundary. */\nexport function useRouteNode(): RouteNode | null {\n  return useContext(CurrentRouteContext);\n}\n\nexport function useContextKey(): string {\n  const node = useRouteNode();\n  if (node == null) {\n    throw new Error('No filename found. This is likely a bug in expo-router.');\n  }\n  return getContextKey(node.contextKey);\n}\n\n/** Provides the matching routes and filename to the children. */\nexport function Route({ children, node }: PropsWithChildren<{ node: RouteNode }>) {\n  return <CurrentRouteContext.Provider value={node}>{children}</CurrentRouteContext.Provider>;\n}\n\nexport { sortRoutesWithInitial, sortRoutes };\n"]}