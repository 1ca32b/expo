{"version":3,"file":"index.js","sourceRoot":"","sources":["../../src/testing-library/index.tsx"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA,oBAAkB;AAClB,mBAAiB;AAGjB,gEAAqE;AACrE,kDAA0B;AAE1B,+CAAiF;AAuCrD,8FAvCA,2BAAa,OAuCA;AAAE,+FAvCA,4BAAc,OAuCA;AAtCzD,0CAAuC;AACvC,+DAA4D;AAE5D,+DAAqD;AAGrD,uBAAuB;AACvB,gEAA8C;AAE9C,QAAQ,CAAC,GAAG,EAAE;IACZ,oBAAK,CAAC,OAAO,EAAE,CAAC;AAClB,CAAC,CAAC,CAAC;AA6BH,SAAgB,YAAY,CAC1B,UAA6B,OAAO,EACpC,EAAE,UAAU,GAAG,GAAG,EAAE,OAAO,EAAE,GAAG,OAAO,KAA0B,EAAE;IAEnE,IAAI,CAAC,aAAa,EAAE,CAAC;IAErB,MAAM,WAAW,GAAG,IAAA,4BAAc,EAAC,OAAO,CAAC,CAAC;IAE5C,qCAAqC;IACrC,OAAO,CAAC,GAAG,CAAC,uBAAuB,GAAG,MAAM,CAAC;IAE7C,MAAM,MAAM,GAAG,IAAA,qBAAM,EACnB,CAAC,mBAAQ,CAAC,OAAO,CAAC,CAAC,WAAW,CAAC,CAAC,QAAQ,CAAC,CAAC,UAAU,CAAC,CAAC,OAAO,CAAC,CAAC,OAAO,CAAC,EAAG,EAC1E,OAAO,CACR,CAAC;IAEF;;;;OAIG;IACH,oBAAK,CAAC,oBAAoB,CAAC,GAAG,EAAE,CAAC,IAAI,CAAC,oBAAoB,EAAE,CAAC,CAAC;IAE9D;;;OAGG;IACH,MAAM,iBAAiB,GAAG,GAAG,EAAE;QAC7B,IAAI,oBAAK,CAAC,aAAa,CAAC,OAAO,EAAE,EAAE;YACjC,MAAM,YAAY,GAAG,oBAAK,CAAC,aAAa,CAAC,YAAY,EAA4B,CAAC;YAClF,IAAI,oBAAK,CAAC,SAAS,KAAK,YAAY,EAAE;gBACpC,oBAAK,CAAC,WAAW,CAAC,YAAY,CAAC,CAAC;aACjC;SACF;IACH,CAAC,CAAC;IAEF,OAAO,MAAM,CAAC,MAAM,CAAC,MAAM,EAAE;QAC3B,WAAW;YACT,iBAAiB,EAAE,CAAC;YACpB,OAAO,oBAAK,CAAC,iBAAiB,EAAE,CAAC,QAAQ,CAAC;QAC5C,CAAC;QACD,WAAW;YACT,iBAAiB,EAAE,CAAC;YACpB,OAAO,oBAAK,CAAC,iBAAiB,EAAE,CAAC,QAAQ,CAAC;QAC5C,CAAC;QACD,eAAe;YACb,iBAAiB,EAAE,CAAC;YACpB,OAAO,oBAAK,CAAC,iBAAiB,EAAE,CAAC,MAAM,CAAC;QAC1C,CAAC;QACD,qBAAqB;YACnB,iBAAiB,EAAE,CAAC;YACpB,OAAO,IAAA,mCAAgB,EAAC,oBAAK,CAAC,SAAU,EAAE,oBAAK,CAAC,OAAQ,CAAC,MAAM,CAAC,CAAC;QACnE,CAAC;QACD,cAAc;YACZ,iBAAiB,EAAE,CAAC;YACpB,OAAO,oBAAK,CAAC,iBAAiB,EAAE,CAAC;QACnC,CAAC;KACF,CAAC,CAAC;AACL,CAAC;AA1DD,oCA0DC","sourcesContent":["import './expect';\nimport './mocks';\n\nimport { NavigationState, PartialState } from '@react-navigation/native';\nimport { render, RenderResult } from '@testing-library/react-native';\nimport React from 'react';\n\nimport { MockContextConfig, getMockConfig, getMockContext } from './mock-config';\nimport { ExpoRoot } from '../ExpoRoot';\nimport { getPathFromState } from '../fork/getPathFromState';\nimport { ExpoLinkingOptions } from '../getLinkingConfig';\nimport { store } from '../global-state/router-store';\nimport { ResultState } from '../exports';\n\n// re-export everything\nexport * from '@testing-library/react-native';\n\nafterAll(() => {\n  store.cleanup();\n});\n\nexport type RenderRouterOptions = Parameters<typeof render>[1] & {\n  initialUrl?: any;\n  linking?: Partial<ExpoLinkingOptions>;\n};\n\ntype Result = ReturnType<typeof render> & {\n  getPathname(): string;\n  getPathnameWithParams(): string;\n  getSegments(): string[];\n  getSearchParams(): Record<string, string | string[]>;\n  getRouterState(): NavigationState<any> | PartialState<any>;\n};\n\ndeclare global {\n  namespace jest {\n    interface Matchers<R> {\n      toHavePathname(pathname: string): R;\n      toHavePathnameWithParams(pathname: string): R;\n      toHaveSegments(segments: string[]): R;\n      toHaveSearchParams(params: Record<string, string | string[]>): R;\n      toHaveRouterState(state: NavigationState<any> | PartialState<any>): R;\n    }\n  }\n}\n\nexport { MockContextConfig, getMockConfig, getMockContext };\n\nexport function renderRouter(\n  context: MockContextConfig = './app',\n  { initialUrl = '/', linking, ...options }: RenderRouterOptions = {}\n): Result {\n  jest.useFakeTimers();\n\n  const mockContext = getMockContext(context);\n\n  // Force the render to be synchronous\n  process.env.EXPO_ROUTER_IMPORT_MODE = 'sync';\n\n  const result = render(\n    <ExpoRoot context={mockContext} location={initialUrl} linking={linking} />,\n    options\n  );\n\n  /**\n   * This is a hack to ensure that React Navigation's state updates are processed before we run assertions.\n   * Some updates are async and we need to wait for them to complete, otherwise will we get a false positive.\n   * (that the app will briefly be in the right state, but then update to an invalid state)\n   */\n  store.subscribeToRootState(() => jest.runOnlyPendingTimers());\n\n  /**\n   * There maybe additional state updates that occur outside of the initial render cycle.\n   * To avoid the user having to call `act` multiple times, we will just manually update the state here.\n   */\n  const updateRouterState = () => {\n    if (store.navigationRef.isReady()) {\n      const currentState = store.navigationRef.getRootState() as unknown as ResultState;\n      if (store.rootState !== currentState) {\n        store.updateState(currentState);\n      }\n    }\n  };\n\n  return Object.assign(result, {\n    getPathname(this: RenderResult): string {\n      updateRouterState();\n      return store.routeInfoSnapshot().pathname;\n    },\n    getSegments(this: RenderResult): string[] {\n      updateRouterState();\n      return store.routeInfoSnapshot().segments;\n    },\n    getSearchParams(this: RenderResult): Record<string, string | string[]> {\n      updateRouterState();\n      return store.routeInfoSnapshot().params;\n    },\n    getPathnameWithParams(this: RenderResult): string {\n      updateRouterState();\n      return getPathFromState(store.rootState!, store.linking!.config);\n    },\n    getRouterState(this: RenderResult) {\n      updateRouterState();\n      return store.rootStateSnapshot();\n    },\n  });\n}\n"]}